DISKUTIL(8)                 System Manager's Manual                DISKUTIL(8)

NNAAMMEE
     ddiisskkuuttiill – modify, verify and repair local disks

SSYYNNOOPPSSIISS
     ddiisskkuuttiill [qquuiieett] _v_e_r_b [_s_u_b_V_e_r_b] [_o_p_t_i_o_n_s]

DDEESSCCRRIIPPTTIIOONN
     ddiisskkuuttiill manipulates the structure of local disks. It provides
     information about, and allows the administration of, partitioning
     schemes, layouts, and formats of disks. This includes hard disks, solid
     state disks, optical discs, disk images, APFS volumes, CoreStorage
     volumes, and AppleRAID sets.  It generally manipulates whole volumes
     instead of individual files and directories.

CCAAUUTTIIOONN
     Many ddiisskkuuttiill commands, if improperly used, can result in data loss. Most
     commands do not present confirmation prompts.  You should back up your
     data before using any of these commands.

VVEERRBBSS
     Each command verb is listed with its description and individual
     arguments.

     lliisstt [--pplliisstt] [iinntteerrnnaall | eexxtteerrnnaall] [pphhyyssiiccaall | vviirrttuuaall] [_d_e_v_i_c_e]
                List disks, including internal and external disks, whole disks
                and partitions, and various kinds of virtual or offline disks.

                If no argument is given, then all whole disks and their
                partitions are listed.

                You can limit the number of disks shown by specifying
                filtering arguments such as iinntteerrnnaall above, and/or a _d_e_v_i_c_e
                disk. When limiting by a disk, you can specify either a whole
                disk, e.g. disk0, or any of its slices, e.g. disk0s3, but
                filtering is only done at the whole disk level (disk0s3 is a
                synonym for disk0 in this case).

                If --pplliisstt is specified, then a property list will be emitted
                instead of the normal user-readable output.

                A script could interpret the results of ddiisskkuuttiill lliisstt --pplliisstt
                and use ddiisskkuuttiill iinnffoo --pplliisstt as well as ddiisskkuuttiill
                lliissttFFiilleessyysstteemmss --pplliisstt for more detailed information.

                The top-to-bottom appearance of all whole disks is sorted in
                numerical order by unit (whole disk) number.  However, within
                each whole disk's "sublist" of partitions, the ordering
                indicates actual on-disk location. The first disk item listed
                represents the partition which is located most near the
                beginning of its encompassing whole disk, and so on.

                When viewed this way, the slice (partition) parts of the BSD
                disk identifiers may, in certain circumstances, not appear in
                numerical order.  This is normal and is likely the result of a
                recent partition map editing operation in which volumes were
                kept mounted.

                Note that both human-readable and plist output are sorted as
                described above.

                See the DDEEVVIICCEESS section below for the various forms that the
                _d_e_v_i_c_e specification may take for this and all of the other
                ddiisskkuuttiill verbs.

     iinnffoo | iinnffoorrmmaattiioonn [--pplliisstt] _d_e_v_i_c_e | --aallll
                Get detailed information about a specific whole disk or
                partition.  If --pplliisstt is specified, then a property list
                instead of the normal user-readable output will be emitted.
                If --aallll is specified, then all disks (whole disks and their
                partitions) are processed.

     aaccttiivviittyy
                Continuously display system-wide disk manipulation activity as
                reported by the Disk Arbitration framework until interrupted
                with a signal (e.g. by typing Control-C).

                This can be useful to watch system-wide activity of disks
                coming on-line or being ejected, volumes on disks being
                mounted or unmounted, volumes being renamed, etc.  However,
                this output must never be parsed; programs should become Disk
                Arbitration clients instead.

                For debugging information, such as the monitoring of
                applications dissenting (attempting to deny) activities for
                disks for which they have registered an interest, you must use
                the logging features of the ddiisskkaarrbbiittrraattiioonndd daemon. Programs
                needing this information must become Disk Arbitration clients.

     lliissttFFiilleessyysstteemmss [--pplliisstt]
                Show the file system personalities available for formatting in
                ddiisskkuuttiill when using the erasing and partitioning verbs.  This
                is a subset of the complete set of personalities exported by
                the various file system bundles that may be installed in the
                system.  Also shown are some shortcut aliases for common
                personalities.  See the FFOORRMMAATT section below for more details.
                If --pplliisstt is specified, then a property list instead of the
                normal user-readable output will be emitted.

     uunnmmoouunntt | uummoouunntt [ffoorrccee] _d_e_v_i_c_e
                Unmount a single volume.  FFoorrccee will force-unmount the volume
                (less kind to any open files; see also uummoouunntt (8)).

                Up to a few seconds (or more) may be required for any Disk
                Arbitration dissenters in the system to approve the unmount,
                and/or for the file system to flush data.  This verb gives up
                and returns failure after a maximum of 1 minute in most
                situations.

     uunnmmoouunnttDDiisskk | uummoouunnttDDiisskk [ffoorrccee] _d_e_v_i_c_e
                Given a disk containing a partition map, unmount all of its
                volumes. That is, unmounts are attempted for the map's
                partitions containing file system volumes, as well as for
                "virtual" volumes exported by storage systems which import
                data from the map's partitions.  Storage systems supported
                include APFS, AppleRAID, and CoreStorage.

                FFoorrccee will force-unmount the volumes (less kind to any open
                files; see also uummoouunntt (8)).

                You should specify a whole disk, but all volumes of the whole
                disk are attempted to be unmounted even if you specify a
                partition.

     eejjeecctt _d_e_v_i_c_e
                Eject a disk.  Media will become offline for the purposes of
                being a data store for file systems or being a member of
                constructs such as software RAID or direct data.
                Additionally, removable media will become eligible for safe
                manual removal; automatically-removable media will begin its
                physical (motorized) eject sequence.

     mmoouunntt [rreeaaddOOnnllyy] [nnoobbrroowwssee] [--mmoouunnttOOppttiioonnss _o_p_t_i_o_n [, _o_p_t_i_o_n]]
                [--mmoouunnttPPooiinntt _p_a_t_h] _d_e_v_i_c_e
                Mount a single volume.

                If rreeaaddOOnnllyy is specified, then the file system is mounted
                read-only, even if writing is supported or allowed by the
                volume's underlying file system, device, media, or user (e.g.
                the super-user).  If nnoobbrroowwssee is specified, then the file
                system is mounted with a recommendation to prevent display
                (e.g. by the Finder) to the end user.  These options are
                equivalent to passing rrddoonnllyy or nnoobbrroowwssee as "-o" arguments to
                the appropriate file system bundle's mmoouunntt (8) program.  If
                --mmoouunnttOOppttiioonnss is specified, then the argument strings you
                specify will be passed (by diskarbitrationd) verbatim to "-o";
                multiple arguments must be separated with commas.

                Up to a few seconds (or much longer in rare cases) may be
                required for any Disk Arbitration dissenters or disk claimers
                in the system to approve the mount, and/or for the file system
                to complete a minimal fsck(8).  (For example, Disk Arbitration
                might invoke ffsscckk__aappffss --qq before mounting an APFS Volume.)
                This verb gives up and returns failure after a maximum of 1
                minute in most situations.

                If --mmoouunnttPPooiinntt is specified, then your path, rather than the
                standard path of /Volumes/VolumeName or
                /System/Volumes/VolumeName, will be used as the view into the
                volume file content; a directory at that path must already
                exist.

     mmoouunnttDDiisskk _d_e_v_i_c_e
                Mount all mountable and UI-browsable volumes on the given
                partition map; that is, a mount is attempted on the directly-
                mountable volume, if any, on each of the whole disk's
                partitions. However, "virtual" volumes, such as those are
                implied by e.g. Core Storage Physical Volumes, AppleRAID
                Members, etc., are not handled.  You should specify a whole
                disk, but all volumes of the whole disk are attempted to be
                mounted even if you specify a partition.

     rreennaammee | rreennaammeeVVoolluummee _d_e_v_i_c_e _n_a_m_e
                Rename a volume.  Volume names are subject to file system-
                specific alphabet and length restrictions.

     eennaabblleeJJoouurrnnaall _d_e_v_i_c_e
                Enable journaling on an HFS+ volume.  This works whether or
                not the volume is currently mounted (the volume is temporarily
                mounted if necessary).  Ownership of the affected disk is
                required.

     ddiissaabblleeJJoouurrnnaall [ffoorrccee] _d_e_v_i_c_e
                Disable journaling on an HFS+ volume.  This normally works
                whether or not the volume is currently mounted (the volume is
                temporarily mounted if necessary).  If the ffoorrccee option is
                specified, then journaling is disabled directly on disk; in
                this case, the volume must not be mounted.  Ownership of the
                affected disk is required.

     mmoovveeJJoouurrnnaall eexxtteerrnnaall _j_o_u_r_n_a_l_D_e_v_i_c_e _d_e_v_i_c_e
                Create a 512MB Apple_Journal partition using the _j_o_u_r_n_a_l_D_e_v_i_c_e
                partition to serve as a journal for the volume _d_e_v_i_c_e_. For
                best results, _j_o_u_r_n_a_l_D_e_v_i_c_e should be a partition on a
                different whole-disk than the volume itself.

                The journal for _d_e_v_i_c_e will be moved externally onto the newly
                created Apple_Journal partition.

                Since the _j_o_u_r_n_a_l_D_e_v_i_c_e you specify will invariably be larger
                than 512MB, a new HFS+ partition will be created following the
                Apple_Journal partition to fill the remaining space.

                Moving the journal works whether or not the volume is mounted,
                provided journaling is enabled on that volume. No errors are
                currently supported to flag attempts to move journals on
                volumes that do not have journaling enabled.  If you have
                multiple volumes for which you want external journals, each
                must have its own external Apple_Journal partition.  Ownership
                of the affected disks is required.

     mmoovveeJJoouurrnnaall iinntteerrnnaall _d_e_v_i_c_e
                Move the journal for _d_e_v_i_c_e back locally (onto that same
                device).  Ownership of the affected disk is required.

     eennaabblleeOOwwnneerrsshhiipp _d_e_v_i_c_e
                Enable ownership of a volume.  The on-root-disk Volume
                Database at /var/db/volinfo.database is manipulated such that
                the User and Group ID settings of files, directories, and
                links (file system objects, or "FSOs") on the target volume
                are taken into account.

                This setting for a particular volume is persistent across
                ejects and injects of that volume as seen by the current OS,
                even across reboots of that OS, because of the entries in this
                OS's Volume Database.  Note thus that the setting is not kept
                on the target disk, nor is it in-memory.

                For some locations of devices (e.g. internal hard disks),
                consideration of ownership settings on FSOs is the default.
                For others (e.g. plug-in USB disks), it is not.

                When ownership is disabled, Owner and Group ID settings on
                FSOs appear to the user and programs as the current user and
                group instead of their actual on-disk settings, in order to
                make it easy to use a plug-in disk of which the user has
                physical possession.

                When ownership is enabled, the Owner and Group ID settings
                that exist on the disk are taken into account for determining
                access, and exact settings are written to the disk as FSOs are
                created.  A common reason for having to enable ownership is
                when a disk is to contain FSOs whose User and Group ID
                settings, and thus permissions behavior overall, is critically
                important, such as when the plug-in disk contains system files
                to be changed or added to.

                See also the vsdbutil(8) command.  Running as root is
                required.

     ddiissaabblleeOOwwnneerrsshhiipp _d_e_v_i_c_e
                Disable ownership of a volume.  See eennaabblleeOOwwnneerrsshhiipp above.
                Running as root is required.

     vveerriiffyyVVoolluummee _d_e_v_i_c_e
                Verify the file system data structures of a volume.  The
                appropriate fsck program is executed and the volume is
                attempted to be left mounted or unmounted as it was before the
                command.  Any underlying Storage System (e.g. Core Storage,
                APFS) is verified before the target volume itself.  In certain
                cases, "live" verify, including of the boot volume, is
                supported.  Ownership of the disk to be verified is required.

     rreeppaaiirrVVoolluummee _d_e_v_i_c_e
                Repair the file system data structures of a volume.  The
                appropriate fsck program is executed and the volume is
                attempted to be left mounted or unmounted as it was before the
                command.  Any underlying Storage System (e.g. Core Storage,
                APFS) is repaired before the given target volume.  In most
                cases (e.g. except mount-read-only), the target volume must be
                unmountable; in all cases, the underlying storage media must
                be writable.  "Live" repair (e.g. of a file-writable mounted
                volume) is not supported.  Ownership of the affected disk is
                required.

     vveerriiffyyDDiisskk _d_e_v_i_c_e
                Verify the partition map layout of a whole disk intended for
                booting or data use on a Macintosh.  The checks further
                include, but are not limited to, the integrity of the EFI
                System Partition, the integrity of any Core Storage Physical
                Volume partitions, and provisioning of space for boot loaders.
                Ownership of the disk to be verified is required; it must be a
                whole disk and must have a partition map.

     rreeppaaiirrDDiisskk _d_e_v_i_c_e
                Repair the partition map layout of a whole disk intended for
                booting or data use on a Macintosh.  The repairs further
                include, but are not limited to, the repair or creation of an
                EFI System Partition, the integrity of any Core Storage
                Physical Volume partitions, and the provisioning of space for
                boot loaders.  Ownership of the affected disk is required; it
                must be a whole disk and must have a partition map.

     rreesseettFFuussiioonn
                For Fusion Drive machines (two internal disk device hardware
                configurations), reset the disk devices in the machine to the
                factory-like state of one empty Fusion volume.

                This command will only run on a machine that contains exactly
                two internal disk devices: one solid-state device (SSD) and
                one rotational device (HDD), or, alternatively, two solid-
                state devices.  This command must be able to make a positive
                identification thereof.  If these requirements are met, you
                are prompted, and if you confirm, the erase and reset begins.

                Both internal disk devices are (re)-partitioned with GPT maps,
                and then they are turned into (used to create) an APFS Fusion
                Drive Container with one APFS Volume.

                All internal-disk data is lost. This includes any "extra"
                partitions (e.g. for Boot Camp or other "user" purposes).  No
                system software is installed and no user data is restored.
                After running this command, you should (re)-install macOS on
                the machine (on the newly-created APFS Volume); otherwise, the
                machine will not be usable (bootable).

                You generally must be booted from the Internet Recovery System
                (CMD-OPT-R) or from an externally-connected macOS boot disk
                (e.g. a USB drive), because you cannot erase a disk that hosts
                the currently-running macOS.

                Externally-connected disk(s) are not affected.  Ownership of
                the affected disks is required.

     eerraasseeDDiisskk  [_-_n_o_E_F_I] _f_o_r_m_a_t _n_a_m_e [AAPPMM[[FFoorrmmaatt]] | MMBBRR[[FFoorrmmaatt]] | GGPPTT[[FFoorrmmaatt]]]
                _d_e_v_i_c_e
                Erase an existing disk, removing all volumes and writing out a
                new partitioning scheme containing one new empty file system
                volume.  If the partitioning scheme is not specified, then an
                appropriate one for the current machine is chosen.  _F_o_r_m_a_t is
                discussed below in the section for the ppaarrttiittiioonnDDiisskk verb.
                Ownership of the affected disk is required.
                If _-_n_o_E_F_I is specified, do not create EFI partition on the
                target disk.

     eerraasseeVVoolluummee _f_o_r_m_a_t _n_a_m_e _d_e_v_i_c_e
                Write out a new empty file system volume (erasing any current
                file system volume) on an existing partition.  The partition
                remains but its data is lost.  _F_o_r_m_a_t is discussed below in
                the section for the ppaarrttiittiioonnDDiisskk verb.

                If you specify FFrreeee SSppaaccee for _f_o_r_m_a_t, the partition itself is
                deleted (removed entirely) from the partition map instead of
                merely being erased.  Ownership of the affected disk is
                required.

     rreeffoorrmmaatt _d_e_v_i_c_e
                Erase an existing volume by writing out a new empty file
                system of the same personality (type) and with the same volume
                name.  Ownership of the affected disk is required.

     eerraasseeOOppttiiccaall [qquuiicckk] _d_e_v_i_c_e
                Erase optical media (CD/RW, DVD/RW, etc.).  QQuuiicckk specifies
                whether the disc recording system software should do a full
                erase or a quick erase.  Ownership of the affected disk is
                required.

     zzeerrooDDiisskk   [ffoorrccee] [sshhoorrtt] _d_e_v_i_c_e
                Erase a device, writing zeros to the media.  The device can be
                a whole-disk or a partition.  In either case, in order to be
                useful again, zeroed whole-disks will need to be
                (re)partitioned, or zeroed partitions will need to be
                (re)formatted with a file system, e.g. by using the
                ppaarrttiittiioonnDDiisskk,, eerraasseeDDiisskk,, or eerraasseeVVoolluummee verbs.

                If you desire a more sophisticated erase algorithm or if you
                need to erase only free space not in use for files, use the
                sseeccuurreeEErraassee verb.

                The ffoorrccee parameter causes best-effort, non-error-terminating,
                forced unmounts and shared-mode writes to be attempted;
                however, this is still no guarantee against drivers which
                claim the disk exclusively. In such cases, you may have to
                first unmount all overlying logical volumes (e.g. CoreStorage
                or AppleRAID). If a disk is partially damaged in just a
                certain unlucky way, you might even have to un-install a kext
                or erase the disk elsewhere.

                The sshhoorrtt parameter causes only a minimal amount of zeros to
                be written ("wipefs"); this is quick. You can use this to
                prevent inadvertent identification by software, e.g. as
                filesystem data.

                Ownership of the affected disk is required.

     rraannddoommDDiisskk [_t_i_m_e_s] _d_e_v_i_c_e
                Erase a whole disk, writing random data to the media.  _T_i_m_e_s
                is the optional (defaults to 1) number of times to write
                random information.  The device can be a whole-disk or a
                partition.  In either case, in order to be useful again,
                randomized whole-disks will need to be (re)partitioned, or
                randomized partitions will need to be (re)formatted with a
                file system, e.g. by using the ppaarrttiittiioonnDDiisskk,, eerraasseeDDiisskk,, or
                eerraasseeVVoolluummee verbs.  If you desire a more sophisticated erase
                algorithm or if you need to erase only free space not in use
                for files, use the sseeccuurreeEErraassee verb.  Ownership of the
                affected disk is required.

     sseeccuurreeEErraassee [ffrreeeessppaaccee] _l_e_v_e_l _d_e_v_i_c_e
                Erase, using a "secure" (but see the NOTE below) method,
                either a whole-disk (including all of its partitions if
                partitioned), or, only the free space (not in use for files)
                on a currently-mounted volume.  Secure erasing makes it harder
                to recover data using "file recovery" software.

                Erasing a whole-disk will leave it useless until it is
                partitioned again.  Erasing freespace on a volume will leave
                your files intact, indeed, from an end-user perspective, it
                will appear unchanged, with the exception that it will have
                attempted to make it impossible to recover deleted files.

                If you need to erase all contents of a partition but not its
                hosting whole-disk, use the zzeerrooDDiisskk or rraannddoommDDiisskk verbs.
                Ownership of the affected disk is required.

                _L_e_v_e_l should be one of the following:

                      ••   0 - Single-pass zero fill erase.

                      ••   1 - Single-pass random fill erase.

                      ••   2 - Seven-pass erase, consisting of zero fills and
                          all-ones fills plus a final random fill.

                      ••   3 - Gutmann algorithm 35-pass erase.

                      ••   4 - Three-pass erase, consisting of two random fills
                          plus a final zero fill.

                NOTE: This kind of secure erase is no longer considered safe.
                Modern devices have wear-leveling, block-sparing, and
                possibly-persistent cache hardware, which cannot be completely
                erased by these commands. The modern solution for quickly and
                securely erasing your data is encryption. Strongly-encrypted
                data can be instantly "erased" by destroying (or losing) the
                key (password), because this renders your data irretrievable
                in practical terms.  Consider using APFS encryption
                (FileVault).

     ppaarrttiittiioonnDDiisskk _d_e_v_i_c_e [-noEFI] [_n_u_m_b_e_r_O_f_P_a_r_t_i_t_i_o_n_s] [AAPPMM[[FFoorrmmaatt]] |
                MMBBRR[[FFoorrmmaatt]] | GGPPTT[[FFoorrmmaatt]]] [_p_a_r_t_1_F_o_r_m_a_t _p_a_r_t_1_N_a_m_e _p_a_r_t_1_S_i_z_e
                _p_a_r_t_2_F_o_r_m_a_t _p_a_r_t_2_N_a_m_e _p_a_r_t_2_S_i_z_e _p_a_r_t_3_F_o_r_m_a_t _p_a_r_t_3_N_a_m_e
                _p_a_r_t_3_S_i_z_e _._._.]

                (re)Partition a disk, removing all volumes.  All volumes on
                this disk will be destroyed.  The _d_e_v_i_c_e parameter specifies
                which whole disk is to be partitioned.  The optional
                _n_u_m_b_e_r_O_f_P_a_r_t_i_t_i_o_n_s parameter specifies the number of
                partitions to create; if given then the number of parameter
                triplets (see below) is expected to match; else, the number of
                triplets alone given will determine the number of partitions
                created.
                If _-_n_o_E_F_I is specified, do not create EFI partition on the
                target disk.

                The optional partitioning scheme parameter forces a particular
                partitioning scheme; if not specified, a suitable default is
                chosen.  They are:

                      ••   AAPPMM[[FFoorrmmaatt]] specifies that an Apple Partition Map
                          scheme should be used.  This is the traditional
                          Apple partitioning scheme used to start up a
                          PowerPC-based Macintosh computer, to use the disk as
                          a non-startup disk with any Mac, or to create a
                          multiplatform compatible startup disk.

                      ••   MMBBRR[[FFoorrmmaatt]] specifies that a Master Boot Record
                          scheme should be used.  This is the DOS/Windows-
                          compatible partitioning scheme.

                      ••   GGPPTT[[FFoorrmmaatt]] specifies that a GUID Partitioning Table
                          scheme should be used.  This is the partitioning
                          scheme used to start up an Intel-based Macintosh
                          computer.

                For each partition, a triplet of the desired file system
                format, volume name, and size must be specified.  Several
                other ddiisskkuuttiill verbs allow these triplets as well (and for
                them, the _n_u_m_b_e_r_O_f_P_a_r_t_i_t_i_o_n_s parameter is also optional).  The
                triplets must be as follows:

                      ••   _F_o_r_m_a_t names are of the form jhfs+, HFS+, MS-DOS,
                          etc.; a list of formattable file systems (more
                          precisely, specific file system personalities
                          exported by the installed file system bundles) and
                          common aliases is available from the lliissttFFiilleessyysstteemmss
                          verb.

                          _F_o_r_m_a_t guides ddiisskkuuttiill both in what partition type
                          to set for the partitions (slices) as well as what
                          file system structures to initialize therein, using
                          the file system bundle's plist's FormatExecutable
                          setting which usually points to the appropriate
                          formatter program such as newfs_hfs(8).

                          You can specify a _f_o_r_m_a_t of FFrreeee SSppaaccee to skip an
                          area of the disk.

                          You can specify the partition type manually and
                          directly with a _f_o_r_m_a_t of %<human-readable partition
                          type>% such as %%AAppppllee__HHFFSS%% or %<GPT partition type
                          UUID constant>% such as
                          %%4488446655330000--00000000--1111AAAA--AAAA1111--0000330066554433EECCAACC%%;; these imply
                          a _n_a_m_e of %%nnooffoorrmmaatt%% (below).  Human-readable types
                          must be known to the system but UUID types (GPT
                          scheme only) can be arbitrary.

                      ••   _N_a_m_e_s are the initial volume names; they must
                          conform to file system specific restrictions.

                          If a name of %%nnooffoorrmmaatt%% is specified, then the
                          partition is left blank such that the partition
                          space is carved out, the partition type is set
                          according to the file system format name or explicit
                          type, the partition space is partially erased
                          ("wiped"), but a file system structure is not
                          initialized with any file system's formatter
                          program, e.g.  newfs_hfs(8). This is useful for
                          setting up partitions that will contain user-defined
                          (not necessarily file system) data.

                          For a triplet whose _f_o_r_m_a_t is FFrreeee SSppaaccee or a
                          directly-specified partition type, its _n_a_m_e is
                          ignored but a dummy name must nevertheless be
                          present.

                      ••   _S_i_z_e_s are floating point numbers followed by a
                          letter or percent sign as described in the SSIIZZEESS
                          section at the end of this page (e.g. 165536000,
                          55.3T, 678M, 75%, R).

                In addition to explicitly-requested partitions, space (gaps)
                might be allocated to satisfy certain filesystems' position
                and length alignment requirements; space might be allocated
                for possible future booter partition insertion; and indeed,
                actual booter partitions might be implicitly created.

                In particular, there is a rule that unrecognized partitions
                1GiB or larger automatically acquire booters.  Thus, if you
                create an arbitrary partition with e.g.  ddiisskkuuttiill
                ppaarrttiittiioonnDDiisskk ddiisskk00 ggpptt %%1111111122222222--11111111--22222222--11111111--111111112222222211111111%%
                %%nnooffoorrmmaatt%% 33ggiibb jjhhffss++ UUnnttiittlleedd rr, then a booter partition will
                also be created. You can always delete that booter with
                ddiisskkuuttiill eerraasseeVVoolluummee ""FFrreeee SSppaaccee"" dduummmmyy ddiisskk00ss33.

                The last partition is usually automatically lengthened to the
                end of the partition map (disk).  You can specify an exact
                size for your last partition by specifying it as the
                penultimate triplet and specifying an additional (last)
                triplet as FFrreeee SSppaaccee.  Or you can use the RR (remainder) size
                specifier for one of your middle partitions while specifying
                an exact size for your last partition.

                Ownership of the affected disk is required.

     rreessiizzeeVVoolluummee _d_e_v_i_c_e lliimmiittss | mmaappssiizzee [-plist] | RR | _s_i_z_e
                [_n_u_m_b_e_r_O_f_P_a_r_t_i_t_i_o_n_s] [_p_a_r_t_1_F_o_r_m_a_t _p_a_r_t_1_N_a_m_e _p_a_r_t_1_S_i_z_e
                _p_a_r_t_2_F_o_r_m_a_t _p_a_r_t_2_N_a_m_e _p_a_r_t_2_S_i_z_e _p_a_r_t_3_F_o_r_m_a_t _p_a_r_t_3_N_a_m_e
                _p_a_r_t_3_S_i_z_e _._._.]
                Non-destructively resize a volume (partition); you may
                increase or decrease its size.  Alternatively, take no action
                and print information.

                Specifying lliimmiittss instead of _s_i_z_e takes no action, but instead
                prints the range of valid values for the target partition,
                taking into account current file system and partition map
                conditions such as files in use and other (immovable)
                partitions following the target.

                Specifying mmaappssiizzee instead of _s_i_z_e takes no action, but
                instead prints the size of the encompassing whole-disk device,
                as well as the size of the entire partition map (all
                partitions less map overhead). The whole-disk device might be
                larger than the partition map if the whole-disk device has
                grown since the partition map was created. Growing a whole-
                disk device is possible with certain enterprise disk (RAID)
                systems.

                The --pplliisstt option will print partition or whole-disk size
                inquiry information in property list format.

                You can grow a volume (partition) (back) to its maximum size
                possible, provided no new partitions have been created that
                are in the way, by specifying RR for the new volume size. You
                should use RR instead of attempting an absolute value such as
                110000%% because the latter cannot count partition map overhead.

                When decreasing the size, new partitions may optionally be
                created to fill the newly-freed space.  To do this, specify
                the _n_u_m_b_e_r_O_f_P_a_r_t_i_t_i_o_n_s_, _f_o_r_m_a_t_, _n_a_m_e_, and _s_i_z_e parameters in
                the same manner as the triplet description for the
                ppaarrttiittiioonnDDiisskk verb.

                Resizing a volume that is currently set as the computer's
                startup disk will invalidate that setting; use the SSttaarrttuupp
                DDiisskk System Preferences panel or bblleessss (8) to reset the
                resized volume as the startup disk.

                _D_e_v_i_c_e refers to a volume; the volume's file system must be
                journaled HFS+.  Valid ssiizzeess are a number followed by a
                capital letter multiplier or percent sign suffix as described
                in the SSIIZZEESS section at the end of this page (e.g. 1.5T, 128M,
                50%).  Ownership of the affected disk is required.

     sspplliittPPaarrttiittiioonn _d_e_v_i_c_e [_n_u_m_b_e_r_O_f_P_a_r_t_i_t_i_o_n_s] [_p_a_r_t_1_F_o_r_m_a_t _p_a_r_t_1_N_a_m_e
                _p_a_r_t_1_S_i_z_e _p_a_r_t_2_F_o_r_m_a_t _p_a_r_t_2_N_a_m_e _p_a_r_t_2_S_i_z_e _p_a_r_t_3_F_o_r_m_a_t
                _p_a_r_t_3_N_a_m_e _p_a_r_t_3_S_i_z_e _._._.]
                Destructively split a volume into multiple partitions.  You
                must supply a list of new partitions to create in the space of
                the old partition; specify these with the _n_u_m_b_e_r_O_f_P_a_r_t_i_t_i_o_n_s_,
                _f_o_r_m_a_t_, _n_a_m_e_, and _s_i_z_e parameters in the same manner as the
                triplet description for the ppaarrttiittiioonnDDiisskk verb.

                For one of your triplets, you can optionally specify the RR
                meta-size in lieu of a constant number value for the _s_i_z_e
                parameter: the substituted value will be exactly the amount of
                space necessary to complete the re-filling of the original
                partition with all of your triplets.

                _D_e_v_i_c_e refers to a volume.  Ownership of the affected disk is
                required.

     mmeerrggeePPaarrttiittiioonnss [ffoorrccee] _f_o_r_m_a_t _n_a_m_e _f_r_o_m_D_e_v_i_c_e _t_o_D_e_v_i_c_e
                Merge two or more partitions on a disk.  All data on merged
                partitions other than the first will be lost.  Data on the
                first partition will be lost as well if the ffoorrccee argument is
                given.

                If ffoorrccee is not given, and the first partition has a resizable
                file system (e.g. JHFS+), the file system will be preserved
                and grown in a data-preserving manner; your _f_o_r_m_a_t and _n_a_m_e
                parameters are ignored in this case. If ffoorrccee is not given,
                and the first partition is not resizable, you are prompted if
                you want to format.  You will also be prompted to format if
                the first partition has an (HFS) Allocation Block Size which
                is too small to support the required growth of the first
                partition; see the --bb option for nneewwffss__hhffss (8).

                If ffoorrccee is given, the final resulting partition is always
                (re)formatted. You should do this if you wish to (re)format to
                a new file system type.  You will be prompted to confirm.

                _F_o_r_m_a_t and _n_a_m_e must always be given, but they have an effect
                only when ffoorrccee is given.

                Merged partitions are required to be ordered sequentially on
                disk (see ddiisskkuuttiill lliisstt for the actual on-disk ordering).  All
                partitions in the range, except for the first one, must be
                unmountable.  Ownership of the affected disk is required.

     aaddddPPaarrttiittiioonn _d_e_v_i_c_e _f_o_r_m_a_t _n_a_m_e _s_i_z_e
                Create a new partition following an existing partition.  The
                new partition will start immediately beyond the end (start +
                size) of the existing partition.

                If _d_e_v_i_c_e is a partition, then a new partition will be created
                in the gap that follows it, formatted with the file system
                personality _f_o_r_m_a_t, with an initial volume name of _n_a_m_e,
                extending for _s_i_z_e, in the same manner as the triplet
                description for the ppaarrttiittiioonnDDiisskk verb.

                If _d_e_v_i_c_e is a (partition map-bearing) whole disk, then the
                new partition will automatically be placed last in the map.

                Alternatively, you can create a new partition without any
                formatting by providing the partition type manually.  To do
                so, pass a _f_o_r_m_a_t parameter in the form of %% followed by a raw
                GPT UUID or valid human-readable ioContent string followed by
                %%, together with %%nnooffoorrmmaatt%% for _n_a_m_e.  In this usage, any old
                on-disk data at the location of the new partition will be
                "wiped" (partially set to zeroes) to avoid any undesired
                interpretation.

                You can request fit-to-fill by specifying a _s_i_z_e of 00.

                The partition map scheme must be GPT.  A gap must exist at the
                target location, which will generally not be the case unless
                you have resized or deleted partitions.  The partition map
                must contain at least one entry (the EFI partition suffices).
                Ownership of the affected disk is required.

     AAPPFFSS | aapp _a_p_f_s_V_e_r_b [...]
                Apple APFS is a system of virtual volumes.  APFS verbs can be
                used to create, manipulate and destroy APFS Containers and
                their APFS Volumes.  Apple APFS defines these types of
                objects:

                      ••   Container - An APFS Container imports one or more
                          APFS Physical Store disks and exports zero or more
                          APFS Volume disks.  Zero or more APFS Containers can
                          exist in (might be attached to) the system at any
                          one time.

                          While attached, the "handle" by which an APFS
                          Container is identified is by its APFS CCoonnttaaiinneerr
                          RReeffeerreennccee disk (device), e.g. "disk5" or
                          "/dev/disk5". You should treat this as an opaque
                          reference token.

                          The CCoonnttaaiinneerr RReeffeerreennccee disk is a synthesized whole-
                          disk which is exported by APFS for identification
                          purposes only; it has no storage. It is associated
                          with the AppleAPFSContainerScheme node in the IO
                          Registry. While APFS Volume device identifiers
                          appear to be of a related form, you should never use
                          the Container Reference as a basis to create device
                          identifiers yourself; use the listing verbs with
                          their plist options instead.

                          An APFS Container has a certain fixed size
                          (capacity) which, via its Physical Store(s), uses
                          physical space on a device. An APFS Container can be
                          resized, but this is not a part of normal operation.

                      ••   Physical Store - An APFS Physical Store is a disk
                          which is imported into (that is, which backs, indeed
                          defines) an APFS Container. An APFS Container can
                          import more than one Physical Store, e.g. for
                          Fusion-style Containers.

                          An APFS Physical Store disk is not necessarily a
                          disk from a partition map; it could be e.g. an
                          AppleRAID Set disk. Therefore, you must never assume
                          that an APFS Physical Store's disk identifier is a
                          2-part form such as disk0s2.

                      ••   Volume - An APFS Volume is an [un]mountable file
                          system volume which is exported from an APFS
                          Container.  Zero or more APFS Volumes may be
                          exported out of an APFS Container.

                          An APFS Volume is identified by its device node,
                          e.g. "disk5s1" or "/dev/disk5s1". The term
                          vvoolluummeeDDeevviiccee is used below to refer to this device
                          node.

                          APFS Volumes have no specified "size" (capacity).
                          Instead, all APFS Volumes consume capacity out of
                          the remaining free space of their parent APFS
                          Container, consuming or returning such capacity as
                          user file data is added or deleted. Note that this
                          means that all Volumes within a Container compete
                          for the Container's remaining capacity. However, you
                          can manage Volume allocation with the optional
                          rreesseerrvvee and qquuoottaa size values.

                          The optional rreesseerrvvee size requests an assured
                          minimum capacity for an APFS Volume. If successfully
                          created, the Volume is guaranteed to be able to
                          store at least this many bytes of user file data.
                          Note that beyond this, the Volume might be able to
                          store even more until constrained by reaching zero
                          free space in its parent Container or by reaching a
                          quota, if any. You can use a rreesseerrvvee to prevent
                          running out of capacity due to competition from
                          other Volumes or from a Container shrink attempt.

                          The optional qquuoottaa size applies a maximum capacity
                          to an APFS Volume, placing a limit on the number of
                          bytes of user file data which can be stored on the
                          Volume. Note that you might not be able to reach
                          this limit if its parent Container becomes full
                          first. You can use a qquuoottaa to enforce accounting or
                          to manage against "unfair" premature filling-up of
                          the parent Container due solely to this Volume at
                          the expense of sibling Volumes.

                          APFS Volumes can be tagged with zero or more rroollee
                          metadata flags which give a hint as to their
                          intended use.  Not all combinations of flags are
                          valid, and not all flags are allowed to be set or
                          changed by a user.

                          Efficient file copy cloning (copy-on-write) is
                          supported; see copyfile(3) CCOOPPYYFFIILLEE__CCLLOONNEE..

                          Optional volume-level encryption is supported (see
                          also Volume Groups below).  An APFS Volume can be in
                          an encrypted state because it was converted from a
                          Core Storage encrypted volume, or because it was
                          created as encrypted from its inception (e.g. with
                          the ddiisskkuuttiill aappffss aaddddVVoolluummee --ppaasssspphhrraassee verb) or
                          because FileVault was enabled on it at some later
                          time.  On machines that support hardware encryption,
                          the on-disk-device data for local volumes is
                          encrypted even if FileVault is not enabled; this is
                          termed "encrypted at rest".

                          The format of an APFS Volume's device identifier
                          (volumeDevice) is that of a slice disk of a special
                          whole-disk; both disks are synthesized by APFS. The
                          "whole" identifier number (a positive possibly-
                          multi-digit integer) is arbitrary, and the "slice"
                          numbers (positive possibly-multi-digit integers)
                          count up from 1 with each new Volume. Deleting
                          Volumes may cause gaps in the numbering.  This form
                          appears the same as a partition (map) scheme and
                          partitions, but it is completely unrelated.  For
                          example: If "disk3s2" is a Physical Store defining a
                          Container, then "disk5s1", "disk5s2", and "disk5s3"
                          might be the Container's Volumes; "disk5" exists but
                          is never used directly.

                          Although it has a device node, an APFS Volume's data
                          may only be accessed through its files; 3rd-party
                          code cannot open an APFS Volume device node to
                          "directly" access its on-disk bytes.

                      ••   Snapshot - An APFS Snapshot represents a read-only
                          copy of its parent (or "base") APFS Volume, frozen
                          at the moment of its creation.  An APFS Volume can
                          have zero or more associated APFS Snapshots.

                          APFS Snapshots are normally not discoverable unless
                          the "base" or one of the snapshots is mounted. APFS
                          Snapshots are uniquely identified with a UUID
                          (preferred) or within their parent Volume's
                          namespace by either a numeric identifier or by their
                          name; they can be renamed, but APFS will never allow
                          duplication of names (within a Volume) to occur.

                          APFS Snapshots are mountable; when this occurs, its
                          mount point (separate from and simultaneous with its
                          parent Volume) provides a read-only historic version
                          of the Volume content at Snapshot creation time.

                          You can rreevveerrtt the present state of an APFS Volume
                          back to equality with a Snapshot in its history.
                          This is a destructive reset/restore operation: Once
                          a Volume is reverted, it cannot be brought forward.
                          Any Snapshots between the revert point and the
                          present are lost as well.

                          You can ddeelleettee a Snapshot; this removes the
                          possibility of ever reverting to that Snapshot's
                          state, but does not affect the Volume's present-time
                          content.

                          An APFS Snapshot mount point's "source device" (its
                          statfs(2) ff__mmnnttffrroommnnaammee shown by the mount(8)
                          command) is not necessarily a device node (e.g.
                          disk0s2) as is common; it can be the Snapshot name
                          followed by the '@' character and the "parent"
                          Volume's device node, e.g.
                          "SnapName123@/dev/disk2s1".  See the mount_apfs(8)
                          --ss and fs_snapshot_create(2) commands. However, it
                          is also possible for ff__mmnnttffrroommnnaammee to have a 3-part
                          form ("diskCsVsS") if you are rooted (booted) from
                          an APFS Snapshot; in this case, its "base" Volume
                          (e.g. "diskCsV") will nnoott be mounted.

                      ••   Volume Group - Collections of APFS Volumes can be
                          associated with each other via an APFS Volume Group.
                          Zero or more APFS Volume Groups may exist on any
                          given APFS Container. The "members" (APFS Volumes)
                          of any particular APFS Volume Group must all be on
                          the same APFS Container. There is no such thing as
                          an "empty" (zero-member) APFS Volume Group.

                          APFS Volume Groups are identified using their Volume
                          Group ID (a UUID). Assignment of this ID may be
                          deferred in some cases.

                          A primary use for APFS Volume Groups is realization
                          of macOS installations in which "System"-role (for
                          the operating system) and "Data"-role (for user
                          data) APFS Volumes are functionally linked (overlaid
                          file namespace, crypto info), yet separated for
                          reasons of security, backup, and software update.

                          Cryptographic identity, if any, is shared among all
                          members of an APFS Volume Group.

                APFS itself has no provision for backing up your data.
                Backups should be always be performed on a regular basis and
                before modifying any APFS Container using these commands.

                The following is a list of AAPPFFSS sub-verbs with their
                descriptions and individual arguments.

                lliisstt [--pplliisstt] [_c_o_n_t_a_i_n_e_r_R_e_f_e_r_e_n_c_e_D_e_v_i_c_e]
                           Display APFS objects as a tree. APFS Container(s)
                           are shown with their imported Physical Store(s) and
                           exported Volume(s).

                           All currently-attached APFS Containers in the
                           system are listed unless you specify a
                           _c_o_n_t_a_i_n_e_r_R_e_f_e_r_e_n_c_e_D_e_v_i_c_e, which limits the output
                           to that specific APFS Container family.

                           If --pplliisstt is specified, then a property list will
                           be emitted instead of the normal user-readable
                           output.

                ccoonnvveerrtt _d_e_v_i_c_e [--ddrryyrruunn] [--pprreebboooottSSoouurrccee _y_o_u_r_S_t_a_g_i_n_g_D_i_r_e_c_t_o_r_y]
                           [--nnooPPrreebboooottAAddddiittiioonnss]
                           Non-destructively convert an HFS volume to an APFS
                           Container with a single (but see below) APFS
                           Volume. The APFS Container can later be manipulated
                           (e.g. adding and deleting APFS Volumes) as usual.
                           This verb can be used to convert nonbootable
                           "data"-only volumes as well as "macOS" volumes (see
                           below).

                           The source HFS volume can be located on a GPT
                           partition or on an encrypted or non-encrypted,
                           Fusion or non-Fusion CoreStorage logical volume
                           (LV).  In the latter case, the CoreStorage logical
                           volume group (LVG) is dismantled, including
                           automatic removal of any related Boot Camp
                           Assistant partition(s).

                           If --ddrryyrruunn is specified, all calculations, checks,
                           and some data moving is performed, but your disk is
                           left as valid HFS (headers remain declared as HFS,
                           partition types are left alone, etc).

                           For volumes currently or planned to be macOS-
                           bearing (and bootable), you can optionally specify
                           --pprreebboooottSSoouurrccee with your own staging directory of
                           macOS boot items; a Preboot Role APFS Volume with a
                           UUID directory will automatically be created as
                           part of the conversion process to facilitate macOS
                           bootstrap.  Normally your directory should be
                           writable; additional (cryptographic and EFI
                           rendering) items are automatically added to your
                           directory prior to conversion and are not removed
                           afterwards.  You can opt-out of automatic item
                           addition with the --nnooPPrreebboooottAAddddiittiioonnss option.

                           Ownership of the affected disks is required.

                ccrreeaattee _d_e_v_i_c_e [_d_e_v_i_c_e] _n_a_m_e
                           Convenience verb which creates an empty APFS
                           Container and then adds one APFS Volume with the
                           given name.  The APFS Volume will have default
                           attributes such as no encryption, no capacity
                           reserve nor quota, etc.  If you specify more than
                           one device, a Fusion Container is created, with the
                           performance parts assigned automatically.  This is
                           a combination of the ddiisskkuuttiill aappffss ccrreeaatteeCCoonnttaaiinneerr
                           and ddiisskkuuttiill aappffss aaddddVVoolluummee verbs.

                           Ownership of the affected disks is required.

                ccrreeaatteeCCoonnttaaiinneerr [--mmaaiinn] _d_e_v_i_c_e [--sseeccoonnddaarryy] [_d_e_v_i_c_e]
                           Create an empty APFS Container.  The device(s)
                           specified become APFS Physical Stores.  If you
                           specify more than one device, a Fusion Container is
                           created.

                           For Fusion cases, if you do not explicitly use the
                           --mmaaiinn and --sseeccoonnddaarryy options, the performance
                           duties are assigned automatically; this is
                           preferred.  Rotational vs. solid-state hardware
                           design must be detectable; this is often not the
                           case for external disks. Solid-state hardware is
                           welcome but not required; it is the identification
                           which holds as a hard requirement with this usage.

                           Alternatively, you can explicitly specify --mmaaiinn and
                           --sseeccoonnddaarryy devices; if you do so, you must specify
                           both.  The "main" device is assumed to be "faster"
                           (you should use solid-state hardware if available),
                           while the "secondary" device is assumed to be
                           "slower" and is often used to store OS-associated
                           "auxiliary" data such as a Boot Camp Assistant
                           partition.

                           You cannot mix the use of disks from a disk image
                           and not from a disk image.

                           After running this command, you may add APFS
                           Volumes with the ddiisskkuuttiill aappffss aaddddVVoolluummee verb; you
                           must do this at least once in order to "use" the
                           new Container.

                           Ownership of the affected disks is required.

                ddeelleetteeCCoonnttaaiinneerr [--ffoorrccee] _c_o_n_t_a_i_n_e_r_R_e_f_e_r_e_n_c_e_D_e_v_i_c_e |
                           _p_h_y_s_i_c_a_l_S_t_o_r_e_D_e_v_i_c_e [_n_e_w_N_a_m_e] [_n_e_w_F_o_r_m_a_t _n_e_w_N_a_m_e
                           _n_e_w_S_i_z_e]
                           Destroy an existing APFS Container, including all
                           of its APFS Volumes.  Data on all of those volumes
                           will be lost.

                           You can identify the APFS Container by its
                           Container Reference disk (preferred), or by one of
                           its Physical Store disk(s).

                           The APFS Volumes are unmounted first; this process
                           may not succeed if one or more is busy, in which
                           case deleteContainer is aborted and all data is
                           left intact (although some volumes might now be
                           unmounted).

                           Otherwise, all APFS Volumes are deleted, their
                           encryption-store entries are removed as applicable,
                           the parent APFS Container is deleted, and the APFS
                           Container's former Physical Store(s) are disposed
                           of as follows:

                           If you did not specify a _n_e_w_N_a_m_e and all Physical
                           Stores are partitions, then those partitions are
                           deleted (turned into free space).  You might then
                           wish to use ddiisskkuuttiill aaddddPPaarrttiittiioonn to re-purpose the
                           newly-created gap in your partition map.

                           If you did specify a _n_e_w_N_a_m_e, or if one or more
                           Physical Stores are whole disks (e.g. AppleRAID),
                           then they are reformatted (as something other than
                           APFS) with volume name(s) based on _n_e_w_N_a_m_e.

                           If you specified the triplet of _n_e_w_F_o_r_m_a_t _n_e_w_N_a_m_e
                           _n_e_w_S_i_z_e in the same manner as when using the
                           ppaarrttiittiioonnDDiisskk verb, then they are each reformatted
                           with the specified format and volume names based on
                           _n_e_w_N_a_m_e.  Only a _n_e_w_S_i_z_e of 00 (fit-to-fill) is
                           currently supported.

                           If your APFS Container is damaged, a Container
                           Reference for it might not exist or it might not be
                           functional. In this case, you can reclaim your
                           former APFS Physical Store disk(s) by specifying
                           the --ffoorrccee option; this activates an alternate
                           last-resort mode. In this mode, if you had more
                           than one Physical Store (e.g. the Fusion case) and
                           the Container is sufficiently damaged, you might
                           have to delete each Physical Store manually.  You
                           should normally avoid this mode.

                           Ownership of the affected disks is required.

                rreessiizzeeCCoonnttaaiinneerr _c_o_n_t_a_i_n_e_r_R_e_f_e_r_e_n_c_e_D_e_v_i_c_e | _p_h_y_s_i_c_a_l_S_t_o_r_e_D_e_v_i_c_e
                           lliimmiittss [-plist] | _s_i_z_e [_p_a_r_t_1_F_o_r_m_a_t _p_a_r_t_1_N_a_m_e
                           _p_a_r_t_1_S_i_z_e _p_a_r_t_2_F_o_r_m_a_t _p_a_r_t_2_N_a_m_e _p_a_r_t_2_S_i_z_e
                           _p_a_r_t_3_F_o_r_m_a_t _p_a_r_t_3_N_a_m_e _p_a_r_t_3_S_i_z_e _._._.]
                           Resize an existing APFS Container by specifying
                           either an APFS Container Reference (preferred) or
                           an APFS Physical Store partition, plus a proposed
                           new size.  Alternatively, take no action and print
                           constraint information.  The operation is live,
                           non-destructive, and does not mount or unmount any
                           APFS Volumes.

                           If you specify an APFS Container Reference and that
                           Container imports more than one Physical Store (in
                           e.g. Fusion setups), the appropriate Physical Store
                           will be chosen automatically.

                           Specifying lliimmiittss instead of a _s_i_z_e causes no
                           action to be taken, but instead prints a range of
                           valid values, taking into account various
                           constraints; the --pplliisstt option will print this
                           information in property list format.

                           Shrinks are constrained by the amount of data usage
                           by all APFS Volumes on the targeted or implied APFS
                           Container.  Contributing to this data usage is the
                           file content on the APFS Volumes, the existence of
                           quotas and/or reserves, the usage of APFS Snapshots
                           (e.g. by Time Machine), and metadata overhead.

                           Grows are constrained by the amount of partition
                           map free space trailing the targeted or implied
                           Physical Store partition.

                           When shrinking, new partitions may optionally be
                           created to fill the newly-freed space.  To do this,
                           specify the _f_o_r_m_a_t_, _n_a_m_e_, and _s_i_z_e parameters in
                           the same manner as the triplet description for the
                           ppaarrttiittiioonnDDiisskk verb.

                           You can specify a _s_i_z_e of zero ((00)) to grow the
                           targeted APFS Physical Store such that all
                           remaining space is filled to the next partition or
                           the end of the partition map.

                           Ownership of the affected disks is required, and
                           all APFS Volumes on the Container must be unlocked.

                aaddddVVoolluummee  _c_o_n_t_a_i_n_e_r_R_e_f_e_r_e_n_c_e_D_e_v_i_c_e _f_i_l_e_s_y_s_t_e_m _n_a_m_e
                           [--ppaasssspprroommpptt] | [--ppaasssspphhrraassee _p_a_s_s_p_h_r_a_s_e] |
                           [--ssttddiinnppaasssspphhrraassee] [--ppaasssspphhrraasseeHHiinntt _p_a_s_s_p_h_r_a_s_e_H_i_n_t]
                           [--rreesseerrvvee _r_e_s_e_r_v_e] [--qquuoottaa _q_u_o_t_a] [--rroollee _r_o_l_e_s]
                           [--ggrroouupp[[WWiitthh]] | --ssiibblliinngg _g_r_o_u_p_D_e_v_i_c_e] [--nnoommoouunntt]
                           [--mmoouunnttppooiinntt _m_o_u_n_t_p_o_i_n_t]
                           Add a new APFS Volume to an existing APFS
                           Container. Files can then be stored on this newly-
                           created APFS Volume.

                           The _f_i_l_e_s_y_s_t_e_m parameter sets the permanent APFS
                           personality for this new APFS Volume; you should
                           specify AAPPFFSS or CCaassee--sseennssiittiivvee AAPPFFSS..

                           The new APFS Volume will be unencrypted unless you
                           specify one of the passphrase options, in which
                           case the volume will be encrypted from the
                           beginning of its existence (as opposed to having
                           encryption applied later); the user which is added
                           will be the "Disk User".  The optional
                           _p_a_s_s_p_h_r_a_s_e_H_i_n_t is a user-defined string that can be
                           displayed even while an encrypted APFS Volume is
                           locked.

                           APFS Volumes have no fixed size; they allocate
                           backing store on an as-needed basis.  You can
                           specify the _r_e_s_e_r_v_e parameter to guarantee a
                           minimum amount of space for your volume; at least
                           that many bytes will be available for file data.
                           You can also specify the _q_u_o_t_a parameter to limit
                           your volume's file usage to a maximum amount; no
                           more than that many bytes will be available for
                           file data, even if there is otherwise enough space
                           in the parent APFS Container.  You can specify both
                           _r_e_s_e_r_v_e and _q_u_o_t_a simultaneously; however, the
                           reserve is not allowed to be larger than the quota.

                           APFS Volumes can be tagged with certain role meta-
                           data flags. You can supply the _r_o_l_e_s parameter with
                           any combination of one or more of meta-data flags
                           from AAPPFFSS VVOOLLUUMMEE RROOLLEESS section below or 00 as a no-
                           op for scripting convenience.  Note that you may be
                           limited to only one role at a time and various
                           other rules.

                           If you specify --ggrroouuppWWiitthh, your new APFS Volume
                           will become a member of the same APFS Volume Group
                           as the APFS Volume _g_r_o_u_p_D_e_v_i_c_e.  If _g_r_o_u_p_D_e_v_i_c_e is
                           not yet associated with any group, such will be
                           created automatically when appropriate.

                           The new APFS Volume is explicitly mounted after
                           creation; you can specify --nnoommoouunntt to leave it
                           unmounted, or, you can supply a "custom" _m_o_u_n_t_p_o_i_n_t
                           path, in which case you must be root, the directory
                           must already exist, and you must delete the
                           directory yourself when you unmount.

                           Ownership of the affected disks is required.

                ddeelleetteeVVoolluummee _v_o_l_u_m_e_D_e_v_i_c_e
                           Remove the given APFS Volume from its APFS
                           Container. All of the Volume's data will be lost.
                           Additionally, a best-effort (error ignored) attempt
                           is made to remove any corresponding XART, Preboot,
                           and Recovery entries.

                           Ownership of the affected disks is required.

                ddeelleetteeVVoolluummeeGGrroouupp _v_o_l_u_m_e_G_r_o_u_p_U_U_I_D
                           Remove all APFS Volumes belonging to the given APFS
                           Volume Group from its APFS Container.  All of the
                           Volumes' data will be lost.  Additionally, a best-
                           effort (error ignored) attempt is made to remove
                           any corresponding XART, Preboot, and Recovery
                           entries for each Volume.  It is then positively
                           verified that the Volume Group no longer exists.

                           Removal will not start unless all Volumes in the
                           Group can first be successfully unmounted.

                           Ownership of the parent APFS Container is required.

                eerraasseeVVoolluummee _v_o_l_u_m_e_D_e_v_i_c_e --nnaammee _n_e_w_N_a_m_e [--ppaasssspprroommpptt] |
                           [--ppaasssspphhrraassee _p_a_s_s_p_h_r_a_s_e] | [--ssttddiinnppaasssspphhrraassee]
                           [--ppaasssspphhrraasseeHHiinntt _p_a_s_s_p_h_r_a_s_e_H_i_n_t] [--rroollee _r_o_l_e_s]
                           [--ggrroouupp[[WWiitthh]] | --ssiibblliinngg _g_r_o_u_p_D_e_v_i_c_e]
                           Erase the contents of an existing APFS Volume; all
                           of its data will be lost.  Unlike ddiisskkuuttiill aappffss
                           ddeelleetteeVVoolluummee, the APFS Volume is not removed from
                           its APFS Container.

                           The "new" APFS Volume will inherit the APFS file
                           system type (Case-sensitive or not) but will not
                           inherit attributes such as name, reserve, quota,
                           role, or encryption status.

                           The "new" APFS Volume will be unencrypted, unless
                           you supply passphrase options in the same manner as
                           ddiisskkuuttiill aappffss aaddddVVoolluummee in which case it will be
                           encrypted and initially accessible by the "Disk
                           User".

                           The --rroollee and --ggrroouuppWWiitthh options function in the
                           same manner as ddiisskkuuttiill aappffss aaddddVVoolluummee.

                           If you need more control, you should delete and
                           (re-)add the Volume instead.

                           Ownership of the affected disks is required.

                cchhaannggeeVVoolluummeeRRoollee | cchhrroollee _v_o_l_u_m_e_D_e_v_i_c_e _r_o_l_e_s
                           Change the role metadata flags of an existing APFS
                           Volume.

                           The _r_o_l_e_s should be any combination of one or more
                           of the role meta-data flags from AAPPFFSS VVOOLLUUMMEE RROOLLEESS
                           section below.  Unspecified flags are left alone,
                           use of lower-case causes flags to be cleared, and
                           use of upper-case causes flags to be set.
                           Alternatively, cclleeaarr will remove all flags, or 00
                           can be used as a no-op for scripting convenience.
                           You should not make any assumptions about the usage
                           or legal combinations of role flags.

                           Ownership of the affected disks is required.

                uunnlloocckkVVoolluummee | uunnlloocckk _v_o_l_u_m_e_D_e_v_i_c_e [--uusseerr ddiisskk | --uusseerr
                           _c_r_y_p_t_o_U_s_e_r_U_U_I_D | --rreeccoovveerryykkeeyycchhaaiinn _f_i_l_e]
                           [--ppaasssspphhrraassee _p_a_s_s_p_h_r_a_s_e] | [--ssttddiinnppaasssspphhrraassee]
                           [--nnoommoouunntt | --mmoouunnttppooiinntt _m_o_u_n_t_p_o_i_n_t]
                           [--ssyysstteemmrreeaaddwwrriittee] [--vveerriiffyy] [--pplliisstt]
                           Unlock and mount an encrypted and locked APFS
                           Volume or verify a passphrase.

                           If you do not supply the --uusseerr option, then all
                           cryptographic users on that APFS Volume are
                           searched for a match; if you supply --uusseerr ddiisskk then
                           the Disk UUID (which equals the APFS Volume UUID)
                           user is assumed; if you supply --uusseerr with a UUID
                           then that specific user is assumed; if you instead
                           supply --rreeccoovveerryykkeeyycchhaaiinn then the Institutional
                           Recovery user (see below) is assumed.

                           You will be prompted interactively for a passphrase
                           unless you specify a passphrase parameter with
                           --ppaasssspphhrraassee or pipe your passphrase into stdin and
                           use --ssttddiinnppaasssspphhrraassee..

                           As an alternative to a passphrase, you can specify
                           --rreeccoovveerryykkeeyycchhaaiinn with a full path to a keychain
                           file if an Institutional Recovery Key has been
                           previously set up on the APFS Volume. The keychain
                           must be unlocked; see security(1) and fdesetup(8)
                           for more information.

                           This command will normally mount the APFS Volume
                           after unlocking; if part of a Volume Group
                           "System"/"Data"-role pair, both will be mounted.
                           If (one of the) volume(s) is of the "System"-role,
                           then it will be mounted as read-only unless you
                           specify the --ssyysstteemmrreeaaddwwrriittee option.  You can skip
                           the explicit mounting step with the --nnoommoouunntt
                           option, or specify a "custom" mountpoint with the
                           --mmoouunnttppooiinntt option. If you specify your own
                           mountpoint path, it must exist and you must have
                           write privileges on it (e.g. usually you must be
                           root).

                           Specifying --vveerriiffyy will test passphrase correctness
                           without affecting the locked or unlocked state.

                           If --pplliisstt is specified, then a property list will
                           be emitted instead of the normal user-readable
                           output; this list provides additional detail.

                           To re-lock the volume, unmount it, e.g. with
                           ddiisskkuuttiill uunnmmoouunntt or ddiisskkuuttiill aappffss lloocckkVVoolluummee..

                           Ownership of the affected disks is required.

                lloocckkVVoolluummee | lloocckk _v_o_l_u_m_e_D_e_v_i_c_e
                           Unmount and lock an encrypted unlocked APFS Volume.
                           This is mostly a synonym for ddiisskkuuttiill uunnmmoouunntt..

                           Ownership of the affected disks is required.

                lliissttCCrryyppttooUUsseerrss | lliissttUUsseerrss | lliissttCCrryyppttooKKeeyyss | lliissttKKeeyyss [--pplliisstt]
                           _v_o_l_u_m_e_D_e_v_i_c_e
                           Show all cryptographic users and special-purpose
                           (e.g. recovery) "users" (keys) that are currently
                           associated with the given APFS Volume, each by
                           their Cryptographic User UUID and usage "type".

                           The usual purpose of an APFS Cryptographic User is
                           to authenticate for unlocking its APFS Volume; any
                           of its users can do so.

                           An APFS Volume need not be encrypted in order to
                           contain crypto users; indeed, other than the Disk
                           User, they should be added before encrypting.

                           Types of Cryptographic Users include the at-most-
                           one-per-Volume "Disk" user, whose UUID value always
                           matches its Volume's UUID; iCloud or personal
                           "Recovery Keys", which are not users per se, but
                           instead store partial crypto keys and are paired
                           with corresponding "Recovery Users" and have fixed-
                           constant UUID values; and, most commonly, "Open
                           Directory" users, whose UUID values match
                           corresponding local macOS Open Directory (OD)
                           account user GUIDs (e.g. the common local user
                           accounts; see dscl(1) for more information).

                           If --pplliisstt is specified, then a property list will
                           be emitted instead of the normal user-readable
                           output.

                cchhaannggeePPaasssspphhrraassee | cchhaannggeeCCrryyppttooUUsseerrPPaasssspphhrraassee | ppaasssswwdd _v_o_l_u_m_e_D_e_v_i_c_e
                           --uusseerr ddiisskk | _c_r_y_p_t_o_U_s_e_r_U_U_I_D [--oollddPPaasssspphhrraassee
                           _o_l_d_P_a_s_s_p_h_r_a_s_e | --oollddSSttddiinnppaasssspphhrraassee]
                           [--nneewwPPaasssspphhrraassee _n_e_w_P_a_s_s_p_h_r_a_s_e |
                           --nneewwSSttddiinnppaasssspphhrraassee]
                           Change the passphrase of the given cryptographic
                           user associated with the given APFS Volume.

                           The old and new passphrases are specified in the
                           same manner as ddiisskkuuttiill aappffss aaddddVVoolluummee; you will be
                           interactively prompted as necessary if you do not
                           specify both.

                           Ownership of the affected disks is required.

                sseettPPaasssspphhrraasseeHHiinntt | sseettCCrryyppttooUUsseerrPPaasssspphhrraasseeHHiinntt | hhiinntt _v_o_l_u_m_e_D_e_v_i_c_e
                           --uusseerr ddiisskk | _c_r_y_p_t_o_U_s_e_r_U_U_I_D --hhiinntt _h_i_n_t_M_e_s_s_a_g_e |
                           --cclleeaarr
                           Set an arbitrary hint string to aid recall of a
                           passphrase for the given cryptographic user
                           associated with the given APFS Volume. Specifying
                           --cclleeaarr will clear any existing hint (no hint is the
                           default).

                           Ownership of the affected disks is required.

                eennccrryyppttVVoolluummee | eennccrryypptt | eennaabblleeFFiilleeVVaauulltt _v_o_l_u_m_e_D_e_v_i_c_e --uusseerr
                           ddiisskk | _e_x_i_s_t_i_n_g_C_r_y_p_t_o_U_s_e_r_U_U_I_D [--ppaasssspphhrraassee
                           _e_x_i_s_t_i_n_g_O_r_N_e_w_P_a_s_s_p_h_r_a_s_e | --ssttddiinnppaasssspphhrraassee]
                           Start encryption of a currently-unencrypted APFS
                           Volume ("Enable FileVault").  Depending on
                           hardware, the operation may be accomplished
                           immediately, or it may proceed "in the background".

                           You can supply an existing cryptographic user UUID,
                           in which case you must supply its corresponding
                           passphrase, or you can supply ddiisskk (or the
                           Disk/Volume UUID) and the corresponding passphrase
                           of the "Disk User", provided the "Disk User"
                           already exists.

                           Alternatively, if no users exist yet on this APFS
                           Volume, you can still supply ddiisskk (or the
                           Disk/Volume UUID), and a "Disk User" will be
                           created with a new passphrase which you supply.
                           This is the only way using ddiisskkuuttiill in which an
                           APFS Volume that has no cryptographics users on it
                           yet can acquire the first such user.

                           The passphrase, interactive or not, is specified in
                           the same manner as ddiisskkuuttiill aappffss aaddddVVoolluummee..

                           Ownership of the affected disks is required.

                ddeeccrryyppttVVoolluummee | ddeeccrryypptt | ddiissaabblleeFFiilleeVVaauulltt _v_o_l_u_m_e_D_e_v_i_c_e [--uusseerr
                           ddiisskk | _e_x_i_s_t_i_n_g_C_r_y_p_t_o_U_s_e_r_U_U_I_D | --rreeccoovveerryykkeeyycchhaaiinn
                           _f_i_l_e] [--ppaasssspphhrraassee _e_x_i_s_t_i_n_g_P_a_s_s_p_h_r_a_s_e |
                           --ssttddiinnppaasssspphhrraassee]
                           Start decryption of a currently-encrypted APFS
                           Volume ("Disable FileVault").  Depending on
                           hardware, the operation may be accomplished
                           immediately, or it may proceed "in the background".

                           The APFS Volume must be in an unlocked state before
                           invoking this operation. Additionally, this
                           operation itself requires that you authenticate.

                           Any existing cryptographic user and its passphrase
                           on the APFS Volume can be supplied, using --uusseerr
                           with either a UUID or the word ddiisskk to specify the
                           "Disk User". If a "Disk User" exists on the APFS
                           Volume and you omit the --uusseerr parameter, then the
                           "Disk User" is assumed.

                           As an alternative to a passphrase, you can specify
                           --rreeccoovveerryykkeeyycchhaaiinn with a full path, in the same
                           fashion as the uunnlloocckkVVoolluummee verb.

                           If you do not supply a passphrase, yet one is
                           required, you will be prompted interactively by
                           cryptographic user UUID.

                           Ownership of the affected disks is required.

                lliissttSSnnaappsshhoottss | lliissttVVoolluummeeSSnnaappsshhoottss [--pplliisstt] _v_o_l_u_m_e_D_e_v_i_c_e |
                           _v_o_l_u_m_e_S_n_a_p_s_h_o_t_D_e_v_i_c_e
                           Show all APFS Snapshots currently associated with
                           the given APFS Volume, each with information such
                           as its Snapshot UUID, Snapshot Name, numeric XID
                           identifier, and possibly other fields.  If
                           applicable, the unique APFS Snapshot which might be
                           limiting APFS Container resizing is identified.

                           If you are rooted (booted) from an APFS Snapshot,
                           you can specify the appropriate 3-part BSD
                           identifier (e.g. "disk1s2s1").

                           If --pplliisstt is specified, then a property list will
                           be emitted instead of the normal user-readable
                           output.

                ddeelleetteeSSnnaappsshhoott _v_o_l_u_m_e_D_e_v_i_c_e --uuuuiidd _s_n_a_p_s_h_o_t_U_U_I_D | --xxiidd _x_i_d |
                           --nnaammee _s_n_a_p_s_h_o_t_N_a_m_e [--wwaaiitt]
                           Remove the given APFS Snapshot from its APFS
                           Volume.  The ability to restore the state of the
                           APFS Volume back to that point in its evolution
                           will be lost.

                           Snapshot removal proceeds in the background and
                           might not be finished when this command exits
                           unless you specify --wwaaiitt.

                           Ownership of the affected disks is required.

                lliisstt[[VVoolluummee]]GGrroouuppss [--pplliisstt] [_c_o_n_t_a_i_n_e_r_R_e_f_e_r_e_n_c_e_D_e_v_i_c_e]
                           Display the relationships among APFS Volumes which
                           are defined by APFS Volume Groups.  For each
                           currently-attached APFS Container in the system,
                           the Container's APFS Volume Groups are shown; for
                           each APFS Volume Group, the Group's membership list
                           of APFS Volumes is shown.

                           If --pplliisstt is specified, then a property list will
                           be emitted instead of the normal user-readable
                           output.

                ddeeffrraaggmmeenntt _c_o_n_t_a_i_n_e_r_D_e_v_i_c_e | _v_o_l_u_m_e_D_e_v_i_c_e ssttaattuuss | eennaabbllee |
                           ddiissaabbllee
                           Manage automatic background defragmentation of user
                           file data at the APFS Container or Volume level.
                           Enablement of defragmentation at the APFS Container
                           level means that any future Volumes which are
                           created out of that Container will have
                           defragmentation enabled by default.

                           Ownership of the affected disks is required.

                uuppddaatteePPrreebboooott _v_o_l_u_m_e_D_e_v_i_c_e [--oodd _o_p_e_n_D_i_r_e_c_t_o_r_y_P_a_t_h]
                           Examine the given APFS Volume's cryptographic user
                           (unlock) records, correlating against matching
                           macOS user metadata (e.g. avatar pictures, password
                           hints, etc) and use this information to update the
                           target volume's associated Preboot Volume. The
                           Preboot Volume is used at EFI firmware time to
                           present a login user interface and to load and boot
                           macOS.

                           MacOS user metadata is sourced from macOS and Open
                           Directory (OD) database files that are searched for
                           on the given _v_o_l_u_m_e_D_e_v_i_c_e, which is normally
                           expected to be a macOS installation.

                           You can use a different Open Directory database by
                           supplying the --oodd option with a full path, e.g.
                           "/Volumes/SomeOtherMacOSVolume/var/db/dslocal/nodes/Default",
                           or with // to use the currently-running macOS (even
                           if _v_o_l_u_m_e_D_e_v_i_c_e is not). Redirecting the database
                           source can lead to loss of access; it must never be
                           done unless you have a precise reason.

                           If some user cannot log in or login metadata is out
                           of date, ddiisskkuuttiill aappffss uuppddaatteePPrreebboooott // can be used
                           as a repair.

                           You should normally never have to use this verb;
                           the Preboot Volume is updated automatically when
                           you use Users & Groups in System Preferences.

                           Ownership of the affected disks is required.

                ssyynnccPPaattcchhUUsseerrss _v_o_l_u_m_e_D_e_v_i_c_e
                           Perform a specific, rarely-needed repair of APFS
                           cryptographic user lock records.  If the target
                           volume is part of an APFS Volume Group, all APFS
                           cryptographic user record lock data is copied from
                           the System-role volume, if any, to the Data-role
                           volume, if any.

                           You must never use this command unless you know
                           precisely why you are doing so.

                           Ownership of the affected disks is required.

     aapppplleeRRAAIIDD | aarr _r_a_i_d_V_e_r_b [...]
                AppleRAID verbs can be used to create, manipulate and destroy
                AppleRAID volumes (Software RAID).  AppleRAID supports three
                basic types of RAID sets:

                      ••   "stripe" - Striped Volume (RAID 0)

                      ••   "mirror" - Mirrored Volume (RAID 1)

                      ••   "concat" - Concatenated Volume (Spanning)

                Of these three basic types, only the "mirror" type increases
                fault-tolerance.  Mirrors may have more than two disks to
                further increase their fault-tolerance.  Striped and
                concatentated volumes are, in fact, more vulnerable to faults
                than single disk volumes.

                From these basic types, "stacked" or "nested" RAID volumes can
                be created.  Stacked RAID sets that make use of mirrored RAID
                sets are fault-tolerant.  For example, these are some of the
                more common combinations of stacked RAID sets:

                      ••   RAID 50 - A striped RAID set of hardware RAID 5
                          disks.

                      ••   RAID 10 - A striped RAID set of mirrored RAID sets.

                      ••   RAID 0+1 - A mirrored RAID set of striped RAID sets.

                      ••   Concatenated Mirror - A concatenation of mirrored
                          RAID sets.

                When creating new RAID sets or adding disks, if possible, it
                is better to specify the entire disk instead of a partition on
                that disk.  This allows the software to reformat the entire
                disk using the most current partition layouts.  When using
                whole disks, the type of partitioning used is selected based
                on the platform type (PPC = APMFormat, Intel = GPTFormat).
                GPT and APM partition formats cannot be mixed in the same RAID
                set.

                In addition to whole disk and partition device names,
                AppleRAID uses UUIDs to refer to existing RAID sets and their
                members.  Existing RAID sets may also be specified by mount
                point (e.g.  _/_V_o_l_u_m_e_/_r_a_i_d_s_e_t). In many cases, using the UUID
                for the device argument is preferred because disk device names
                may change over time when disks are added, disks are removed
                or when the system is rebooted.  If RAID members have been
                physically disconnected from the system or are no longer
                responding, you must use the member's UUID as the command
                argument.  Messages in the system log will refer to RAID sets
                and their member disks by UUID.  For more information on
                specifying device arguments, see the DDEEVVIICCEESS section below.

                AppleRAID is not a replacement for backing up your data.
                Backups should be always be performed on a regular basis and
                before modifying any RAID set using these commands.

                The following is a list of aapppplleeRRAAIIDD sub-verbs with their
                descriptions and individual arguments.

                lliisstt [--pplliisstt | _U_U_I_D]
                           Display AppleRAID volumes with current status and
                           associated member disks.  If _U_U_I_D is specified,
                           only list the RAID set with that AppleRAID Set
                           UUID.  If --pplliisstt is specified, then a property list
                           will be emitted instead of user-formatted output.
                           The --pplliisstt and _U_U_I_D arguments may not both be
                           specified.  ddiisskkuuttiill lliissttRRAAIIDD and ddiisskkuuttiill
                           cchheecckkRRAAIIDD are deprecated synonyms for ddiisskkuuttiill
                           aapppplleeRRAAIIDD lliisstt..

                ccrreeaattee mmiirrrroorr | ssttrriippee | ccoonnccaatt _s_e_t_N_a_m_e _f_o_r_m_a_t _d_e_v_i_c_e_s _._._.
                           Create a new RAID set consisting of multiple disks
                           and/or RAID sets.  _s_e_t_N_a_m_e is used for both the
                           name of the created RAID volume and the RAID set
                           itself (as displayed in lliisstt). e.g. 'diskutil
                           createRAID stripe MyArray JHFS+ disk1 disk2 disk3
                           disk4'.  Ownership of the affected disks is
                           required.  ddiisskkuuttiill ccrreeaatteeRRAAIIDD is a deprecated
                           synonym for ddiisskkuuttiill aapppplleeRRAAIIDD ccrreeaattee..

                ddeelleettee _r_a_i_d_V_o_l_u_m_e
                           Destroy an existing RAID set.  If the RAID set is a
                           mirror with a resizable file system, ddeelleettee will
                           attempt to convert each of the member partitions
                           back into a non-RAID volume while retaining the
                           contained file system.  For concatenated RAID sets
                           with a resizable file system, ddeelleettee will attempt
                           to shrink the file system to fit on the first
                           member partition and convert that to a non-RAID
                           volume.  Ownership of the affected disks is
                           required.  ddiisskkuuttiill ddeessttrrooyyRRAAIIDD is a deprecated
                           synonym for ddiisskkuuttiill aapppplleeRRAAIIDD ddeelleettee..

                rreeppaaiirrMMiirrrroorr _r_a_i_d_V_o_l_u_m_e _n_e_w_D_e_v_i_c_e
                           Repair a degraded mirror by adding a "new" disk
                           given as _n_e_w_D_e_v_i_c_e to the RAID mirror set whose
                           exported disk device or set UUID is given as
                           _r_a_i_d_V_o_l_u_m_e_. The new disk must be the same size or
                           larger than the existing disks in the RAID set.
                           After running this command, you should manually
                           remove the old (orphaned, failed) member(s) with
                           ddiisskkuuttiill aapppplleeRRAAIIDD rreemmoovvee.. Ownership of the
                           affected disk is required.  ddiisskkuuttiill rreeppaaiirrMMiirrrroorr
                           is a deprecated synonym for ddiisskkuuttiill aapppplleeRRAAIIDD
                           rreeppaaiirrMMiirrrroorr..

                aadddd _t_y_p_e _n_e_w_D_e_v_i_c_e _r_a_i_d_V_o_l_u_m_e
                           Add a new member or hot spare to an existing RAID
                           set.  _T_y_p_e can be either _m_e_m_b_e_r or _s_p_a_r_e.  New
                           disks are added live, the RAID volume does not need
                           to be unmounted.  Mirrored volumes support adding
                           both members and hot spares, concatenated volumes
                           only support adding members.  When adding to a
                           mirrored RAID set, the new disk must be the same
                           size or larger than the existing disks in the RAID
                           set.  Adding a hot spare to a mirror will enable
                           autorebuilding for that mirror.  Adding a new
                           member to a concatenated RAID set appends the
                           member and expands the RAID volume.  Ownership of
                           the affected disk is required.  ddiisskkuuttiill aaddddTTooRRAAIIDD
                           is a deprecated synonym for ddiisskkuuttiill aapppplleeRRAAIIDD aadddd..

                rreemmoovvee _o_l_d_D_e_v_i_c_e _r_a_i_d_V_o_l_u_m_e
                           Remove a member or spare from an existing RAID set.
                           Old disks are removed live; the RAID volume does
                           not need to be unmounted.  For missing devices,
                           _o_l_d_D_e_v_i_c_e must be the device's UUID.  Online mirror
                           members with a resizable file system will be
                           converted to non-RAID volumes, spare and offline
                           members will be marked free.  For concatenated RAID
                           sets, only the last member can be removed.  For
                           resizable file systems rreemmoovvee will first attempt to
                           shrink the concatenated RAID set so that the file
                           system fits on the remaining disks.  Ownership of
                           the affected disk is required.  ddiisskkuuttiill
                           rreemmoovveeFFrroommRRAAIIDD is a deprecated synonym for ddiisskkuuttiill
                           aapppplleeRRAAIIDD rreemmoovvee..

                eennaabbllee mmiirrrroorr | ccoonnccaatt _d_e_v_i_c_e
                           Convert a non-RAID disk partition containing a
                           resizable file system (such as JHFS+) into an
                           unpaired mirror or single disk concatenated RAID
                           set.  Disks that were originally partitioned on Mac
                           OS X 10.2 Jaguar or earlier or were partitioned to
                           be Mac OS 9 compatible may not be resizable.
                           Ownership of the affected disk is required.
                           ddiisskkuuttiill eennaabblleeRRAAIIDD is a deprecated synonym for
                           ddiisskkuuttiill aapppplleeRRAAIIDD eennaabbllee..

                uuppddaattee _k_e_y _v_a_l_u_e _r_a_i_d_V_o_l_u_m_e
                           Update the _k_e_y _v_a_l_u_e parameters of an existing RAID
                           set.  Valid keys are:

                                 ••   AAuuttooRReebbuuiilldd - If true, the system
                                     attempts to rebuild degraded mirrored
                                     volumes automatically.  When looking for
                                     devices for rebuild, AppleRAID first
                                     looks for hot spares and then degraded
                                     members.  Use a _v_a_l_u_e of "1" for true and
                                     "0" for false.

                                 ••   SSeettTTiimmeeoouutt - Controls how long the system
                                     waits (in seconds) for a missing device
                                     before degrading a mirrored raid set.
                                     Also controls the amount of time you have
                                     to disconnect all devices from an
                                     unmounted mirror without degrading it.

                           Ownership of the affected disk is required.
                           ddiisskkuuttiill uuppddaatteeRRAAIIDD is a deprecated synonym for
                           ddiisskkuuttiill aapppplleeRRAAIIDD uuppddaattee..

     ccoorreeSSttoorraaggee | ccss _c_o_r_e_S_t_o_r_a_g_e_V_e_r_b [...]
                CoreStorage verbs can be used to gather information about, and
                to remove, CoreStorage volumes.

                CoreStorage maintains a world of virtual disks, somewhat like
                RAID, in which one can easily add or remove imported backing
                store disks, as well as exported usable volumes, to or from a
                pool (or several pools). This provides the user with
                flexibility in allocating their hardware; user or operating
                system data can span multiple physical disks seamlessly, for
                example.

                CoreStorage is deprecated in favor of Apple APFS.

                Apple CoreStorage defines four types of objects, instances of
                which are uniquely represented by a UUID:

                      ••   Logical Volume Group (LVG)

                      ••   Physical Volume (PV)

                      ••   Logical Volume Family (LVF)

                      ••   Logical Volume (LV)

                The Logical Volume Group (LVG) is the top or "pool" level;
                zero or more may exist during any OS boot time session.

                An LVG imports one or more Physical Volumes (PVs). A PV
                represents a device that feeds the LVG storage space; a PV is
                normally real media but it can be a disk image or even an
                AppleRAID Set. A disk offered to be a PV must be a partition
                and the encompassing scheme must be GPT.

                An LVG exports zero or more Logical Volume Families (LVFs). An
                LVF contains properties which govern and bind together all of
                its descendant Logical Volumes (LVs). These properties provide
                settings for Full Disk Encryption (FDE) (such as whether the
                LVs are encrypted, which users have access, etc) and other
                services.  However, at the present time, for the creation of
                any new LVFs, only zero or one LVF per LVG is supported.

                A Logical Volume Family (LVF) exports one or more Logical
                Volumes (LVs).  However, only and exactly one LV per LVF is
                supported.

                A Logical Volume (LV) exports a dev node, upon which a file
                system (such as Journaled HFS+) resides.

                For more information on specifying device arguments, see the
                DDEEVVIICCEESS section below.

                The following is a list of ccoorreeSSttoorraaggee sub-verbs with their
                descriptions and individual arguments.

                lliisstt [--pplliisstt | _U_U_I_D]
                           Display a tree view of the CoreStorage world for
                           all current logical volume groups (LVGs) with
                           member disks (PVs) and exported volumes (LVFs and
                           LVs), with properties and status for each level.
                           If --pplliisstt is specified then a property list will be
                           emitted instead of the formatted tree output; the
                           UUIDs can be used with the ddiisskkuuttiill ccoorreeSSttoorraaggee
                           iinnffoorrmmaattiioonn verb to get properties for the object
                           represented by that UUID.  If _U_U_I_D is specified
                           then an attempt is made to list only that UUID
                           (whatever type of CoreStorage object it may
                           represent).  The --pplliisstt and _U_U_I_D arguments may not
                           both be specified.

                iinnffoo | iinnffoorrmmaattiioonn [--pplliisstt] _U_U_I_D | _d_e_v_i_c_e
                           Display properties of the CoreStorage object (LVG,
                           PV, LVF, or LV) associated with the given
                           CoreStorage UUID or disk.

                ddeelleettee | ddeelleetteeLLVVGG _l_v_g_U_U_I_D | _l_v_g_N_a_m_e
                           Delete a CoreStorage logical volume group. All
                           logical volume families with their logical volumes
                           are removed, the logical volume group is destroyed,
                           and the now-orphaned physical volumes are erased
                           and partition-typed as Journaled HFS+.

                uunnlloocckkVVoolluummee | uunnlloocckkLLVV [--nnoommoouunntt] _l_v_U_U_I_D [--ssttddiinnppaasssspphhrraassee] |
                           [--ppaasssspphhrraassee _p_a_s_s_p_h_r_a_s_e] | [--rreeccoovveerryykkeeyycchhaaiinn _f_i_l_e]
                           Unlock a logical volume and file system, causing it
                           to be attached and mounted.  Data is then
                           accessible in plain form to the file system and
                           applications, while the on-physical-disk backing
                           bytes remain in encrypted form.  A credential must
                           be supplied; you must supply either a "Disk" user
                           passphrase or a recovery keychain file.

                           If no --ppaasssspphhrraassee option is specified, you will be
                           prompted interactively; else, your _p_a_s_s_p_h_r_a_s_e is
                           used. Or, if you specify --ssttddiinnppaasssspphhrraassee then the
                           standard input is read (e.g. so that the passphrase
                           can be securely piped in without having to expose
                           it).

                           Alternatively, you can specify --rreeccoovveerryykkeeyycchhaaiinn
                           with a path to a keychain _f_i_l_e.  The keychain must
                           be unlocked; see security(1) for more information.

                           The locked state means that the CoreStorage driver
                           has not been given authentication information (a
                           passphrase) to interpret the encrypted bytes on
                           disk and thus export a dev node.  This verb unlocks
                           a logical volume family (LVF) and its logical
                           volumes (LVs) by providing that authentication; as
                           the LVs thus appear as dev nodes, any file systems
                           upon them are automatically mounted unless the
                           --nnoommoouunntt option is given.

                           To re-lock the volume, make it offline again by
                           ejecting it, e.g. with ddiisskkuuttiill eejjeecctt.

     iimmaaggee      [----ssttddiinnppaasssspphhrraassee] [----vveerrbboossee] [----pplliisstt] _d_i_s_k_i_m_a_g_e_v_e_r_b
                ddiisskkuuttiill iimmaaggee vveerrbb uses DiskImages framework alongside with
                StorageKit framework to facilitate in manipulating disk
                images. Currently only aattttaacchh , iinnffoo and ccrreeaattee are supported.

                Add vveerrbboossee flag for verbose output.

                Add pplliisstt flag for the _d_i_s_k_i_m_a_g_e_v_e_r_b to produce output in a
                plist format. Intended for other programs to use this flag in
                order to consume the output instead of attempting to parse
                human-readable text.

                Add ssttddiinnppaasssspphhrraassee to read the passphrase from stdin instead
                of prompting for one.

                The following is a list of ddiisskkuuttiill iimmaaggee sub-verbs with their
                descriptions and individual arguments.

                aattttaacchh     [----rreeaaddOOnnllyy] [----nnoobbrroowwssee] [----mmoouunnttPPooiinntt _m_o_u_n_t_P_o_i_n_t]
                           [----mmoouunnttOOppttiioonnss _o_p_t_[_,_o_p_t_]_*] [----mmoouunnttPPoolliiccyy
                           _m_o_u_n_t_P_o_l_i_c_y] [----nnooMMoouunntt] _i_m_a_g_e_-_u_r_l
                           Attach a disk image as a device. Upon success will
                           return the disk identifier matching the attached
                           disk image.

                           _i_m_a_g_e_-_u_r_l can be one of:

                                 ••   Path to an existing disk image file

                                 ••   HTTPS[S] URL representing a disk image
                                     over HTTP[S]

                                 ••   RAM disk in format ram://<size>. See
                                     SIZES. If units are not specified, the
                                     size will be multiplied by block size
                                     (512 bytes). Note, RAM disks cannot be
                                     mounted as they do not have the
                                     appropriate file system during their
                                     creation.

                           If rreeaaddOOnnllyy is specified, then the disk image is
                           attached read-only, even if writing is supported or
                           allowed by the volume's underlying file system,
                           device, media, or user (e.g. the super-user).

                           Mount Policy:

                           Can be one of: nnooMMoouunntt,, aauuttooMMoouunntt,, ffoorrcceeMMoouunntt..

                           By default, will attempt to mount the disk image
                           after attaching it (unless it is a ram disk), in
                           case of no mountable filesystem on the image, the
                           operation will fail ( ffoorrcceeMMoouunntt ). Specifying
                           nnooMMoouunntt flag will skip any mount attempts and only
                           attach the disk image.  Lastly, aauuttooMMoouunntt will
                           attempt to perform a mount after successful attach.
                           In case no mountable filesystem is present the
                           operation will end successfully.

                           nnooMMoouunntt flag behaves the same as specifying
                           mmoouunnttPPoolliiccyy==nnooMMoouunntt.. Note that you cannot specify
                           this flag with conflicting mount policies.

                           Mount only related options (cannot be used with
                           nnooMMoouunntt ):

                           In case mmoouunnttPPooiinntt is supplied, then it will be
                           used as the path to view into the volume; a
                           directory at the supplied path must already exist.
                           Note, that when specifying this option, the disk
                           image should contain only a single mountable
                           entity, otherwise the operation will fail.
                           Additionally, can manipulate the mount operation by
                           passing mmoouunnttOOppttiioonnss,, see mount(8). Can supply
                           multiple options separated by ','. These options
                           will be used during mount operation.  Lastly,
                           nnoobbrroowwssee can be supplied to hide the mounted volume
                           in the disk image from GUI applications (such as
                           Finder).

                iinnffoo       [----eexxttrraa] _i_m_a_g_e_-_u_r_l
                           Print out information about a disk image.
                           The operation includes an attach operation of the
                           image in order to retrieve various details. If the
                           image is already attached, it will remain attached.
                           Otherwise, the image is ejected upon completion.
                           If ----eexxttrraa is specified, additional information
                           will be retrieved for some image types.

                ccrreeaattee     [--ee,, ----eennccrryypptt] [_b_l_a_n_k | _f_r_o_m] _._._.
                           Create a disk image. Either blank or from an
                           existing source.

                           Creates an optionally encrypted disk image.

                           With eennccrryypptt can encrypt the newly created disk
                           image using AES-256.  When creating from source and
                           encryption applies to both, source and destination,
                           stdinpassphrase applies the first passphrase to
                           source and the second to destination.

                           At the end of the operation the image is not
                           mounted.

                           Use bbllaannkk to create a blank disk image.  Use ffrroomm
                           to create the disk image from source (e.g. disk3 /
                           existing disk image).


                           bbllaannkk   [----ffoorrmmaatt _f_o_r_m_a_t] [----ssiizzee _s_i_z_e]
                                   [----vvoolluummeeNNaammee _n_a_m_e] _i_m_a_g_e_-_p_a_t_h
                                   Creates a blank disk image.

                                   The disk image will be created at
                                   iimmaaggee--ppaatthh.. Should be a writable path.

                                   ffoorrmmaatt

                                         ••   RAW     - RAW read-write format
                                             (previously known as UDRW)

                                         ••   UDSB    - Sparse bundle

                                   nnaammee creates an APFS filesystem with the
                                   requested volume name on the image
                                   (default: untitled).

                                   ssiizzee allows to specify the size of the
                                   newly created image, see SIZES.


                           ffrroomm    [----ffoorrmmaatt _f_o_r_m_a_t] ssoouurrccee--ppaatthh
                                   ddeessttiinnaattiioonn--ppaatthh
                                   Creates a disk image from source (e.g.
                                   disk3 or disk image URL).

                                   The disk image will be created at
                                   ddeessttiinnaattiioonn--ppaatthh.. Should be a writable
                                   path.

                                   ffoorrmmaatt

                                         ••   RAW     - RAW read-write format
                                             (previously known as UDRW)

                                         ••   UDRO    - UDIF read-only
                                             uncompressed

                                         ••   UDZO    - UDIF read-only zlib-
                                             compressed

                                         ••   ULFO    - UDIF read-only lzfse-
                                             compressed

                                         ••   ULMO    - UDIF read-only lzma-
                                             compressed

                                         ••   UDSB    - Sparse bundle

                                   ssoouurrccee--ppaatthh should be the source for the
                                   disk image to be created from (e.g. disk3 /
                                   existing disk image).

                rreessiizzee     [--ss,, ----ssiizzee] [----iimmaaggee--oonnllyy] _i_m_a_g_e_-_u_r_l
                           Resizes an existing disk image represented by
                           iimmaaggee--uurrll
                           Prints disk image resize limits when no ssiizzee is
                           specified.

                           In case the image contains a resizable filesystem
                           (e.g. APFS) it will be resized and image limits
                           will be calculated accordingly.

                           In case the image contains one or more partitions,
                           only the last one will be resized based on the
                           input.

                           Only GPT partition tables are supported or
                           partition-less images with APFS.

                           The image should not be attached prior to resizing.

                           ssiizzee The new size of the disk image, should not
                           exceed the size from the disk image limits. Can be
                           either size from size section (see SIZES) or 'min'
                           to resize to minimum size as reported by diskutil.

                           iimmaaggee--oonnllyy Will only resize the disk image and
                           adjust a secondary GPT table to the new size if
                           there is one.


DDEEVVIICCEESS
     A device parameter for any of the above commands (except where explicitly
     required otherwise) can usually be any of the following:

           ••   The ddiisskk iiddeennttiiffiieerr (see below).  Any entry of the form of
               _d_i_s_k_*, e.g.  _d_i_s_k_1_s_9.

           ••   The device node entry containing the ddiisskk iiddeennttiiffiieerr.  Any
               entry of the form of _/_d_e_v_/_[_r_]_d_i_s_k_*, e.g.  _/_d_e_v_/_d_i_s_k_2.

           ••   The volume mount point.  Any entry of the form of _/_V_o_l_u_m_e_s_/_*,
               e.g.  _/_V_o_l_u_m_e_s_/_U_n_t_i_t_l_e_d.  In most cases, a "custom" mount point
               e.g.  _/_y_o_u_r_/_c_u_s_t_o_m_/_m_o_u_n_t_p_o_i_n_t_/_h_e_r_e is also accepted.

           ••   The URL form of any of the volume mount point forms described
               above.  E.g.  _f_i_l_e_:_/_/_/_V_o_l_u_m_e_s_/_U_n_t_i_t_l_e_d or _f_i_l_e_:_/_/_/.

           ••   A UUID.  Any entry of the form of e.g.
               _1_1_1_1_1_1_1_1_-_2_2_2_2_-_3_3_3_3_-_4_4_4_4_-_5_5_5_5_5_5_5_5_5_5_5_5.  The UUID can be a
               "media" UUID which IOKit places in an IOMedia node as derived
               from e.g. a GPT map's partition UUID, or it can be an AppleRAID
               (or CoreStorage) set (LV) or member (PV) UUID.

           ••   A volume name, e.g.  _U_n_t_i_t_l_e_d.  This match is only attempted if
               the given device is not of the form _[_/_d_e_v_/_]_[_r_]_d_i_s_k_*, nor
               _[_/_V_o_l_u_m_e_s_/_]_*.  The match attempt is against the intrinsic
               volume label, not against the terminal component, if mounted,
               of its mount point.

DDIISSKK IIDDEENNTTIIFFIIEERR
     The (BSD) ddiisskk iiddeennttiiffiieerr string variously identifies a physical or
     logical device unit, a session (if any) upon that device, a partition
     (slice) upon that session (if any), a virtual logical volume, or a moment
     in a volume's evolution.  It may take the form of _d_i_s_k_U, _d_i_s_k_U_s_P,
     _d_i_s_k_U_s_Q, _d_i_s_k_U_s_Q_s_P, _d_i_s_k_C, _d_i_s_k_C_s_V, or _d_i_s_k_C_s_V_s_S where C, P, Q, S, U, and
     V are positive decimal integers (possibly multi-digit), and where:

           ••   _U is the device unit.  It may refer to hardware (e.g. a hard
               drive, optical drive, or memory card) or a virtual "drive"
               constructed by software (e.g. an AppleRAID Set, Apple Disk
               Image, CoreStorage LV, etc).

           ••   _C is an APFS Container.  This is a virtual disk constructed by
               APFS to represent a collection of APFS Volumes.  Multiple APFS
               Containers can be active simultaneously.

           ••   _Q is the session and is only included for optical media; it
               refers to the number of times recording has taken place on the
               currently-inserted medium (disc).

           ••   _P is a partition in some partitioning scheme. A partitioning
               scheme divides up a device unit and is also called a "partition
               map" or simply a "map".  Upon a partition, the raw data that
               underlies a user-visible file system is usually present, but it
               may also contain specialized data for certain 3rd-party
               database programs, or data required for the system software
               (e.g. EFI partitions, booter partitions, APM partition map
               data, etc), or, notably, it might contain backing-store
               physical volumes for AppleRAID, CoreStorage, APFS, or other
               (3rd-party) Storage Systems.  For example, a partition disk0s2
               might contain APFS data and have a partition type of
               Apple_APFS; this partition would then be termed an APFS
               Physical Store, out of which an APFS Container disk1 is
               defined, out of which an APFS Volume disk1s1 is exported.

           ••   _V is an APFS Volume; it refers to a virtual logical volume that
               is shared out of an APFS Container.  For example, exported from
               an APFS Container designated as disk1 there might be an APFS
               Volume disk1s1, mountable as a file system and usable for file
               storage via its mountpoint path.

           ••   _S is an APFS Snapshot; it refers to a frozen moment in time of
               the state of files on an APFS Volume.  For example, if APFS
               Container disk6 has an APFS Volume disk6s3, and two APFS
               Snapshots have been "taken" on it, these, when mounted, might
               be designated as disk6s3s1 and disk6s3s2. Zero or more
               snapshots can be persistently defined on a volume, but only
               "active" (mounted) snapshots have disk identifiers.

     Some units (e.g. floppy disks, RAID sets) contain file system data upon
     their "whole" device instead of containing a partitioning scheme with
     partitions.

     Note that some of the forms appear the same and must be distinguished by
     context.  For example, _d_i_s_k_U_s_Q, _d_i_s_k_U_s_S, and _d_i_s_k_C_s_V are all 2-part forms
     that can mean different things: For non-optical media, it identifies a
     partition (on a partition map) upon which (file system) data is stored;
     for optical media, it identifies a session upon which an entire partition
     map (with its partitions with file systems) is stored; for an APFS setup,
     it identifies an APFS Volume. As another example, in "stacked" cases
     (CoreStorage on AppleRAID or APFS on AppleRAID), the 1-part _d_i_s_k_U form
     becomes a CoreStorage PV or APFS PhysicalStore, in contrast with the
     more-common 2-part form.

     It is important for software to avoid relying on numerical ordering of
     any of the parts.  Activities including but not limited to partition
     deletions and insertions, partition resizing, virtual volume deletions
     and additions, device ejects and attachments due to media insertion
     cycles, plug cycles, authentication lock cycles or reboots, can all cause
     (temporary) gaps and non-increments in the numerical ordering of any of
     the parts. You must rely on more persistent means of identification, such
     as the various UUIDs.

SSIIZZEESS
     Wherever a size is emitted as an oouuttppuutt, it is presented as a base-ten
     approximation to the precision of one fractional decimal digit and a
     base-ten SI multiplier, often accompanied by a precise count in bytes.
     Scripts should refrain from parsing this human-readable output and use
     the --pplliisstt option instead.

     Wherever a _s_i_z_e is to be supplied by you as an iinnppuutt, you can provide
     values in a number of different ways, some absolute and some context-
     sensitive.  Values are interpreted as base ten and must be positive with
     no preceding "+".  An integer without a suffix is taken to mean an exact
     number of bytes (e.g. 5368709120).  Multiplier suffixes are optional,
     must follow your value immediately without whitespace, and allow your
     value to be a real number (e.g. 5.1234t).  Some of the specifiers below
     should not have a preceding value at all (e.g. the letter RR for
     "remainder").

     Power-of-ten suffixes:

           ••   BB is bbyytteess (not blocks) where the multiplier is 1.  This suffix
               may be omitted.

           ••   KK[[BB]] is power of ten kkiilloobbyytteess where the multiplier is 1000 (1
               x 10^3).

           ••   MM[[BB]] is power of ten mmeeggaabbyytteess where the multiplier is 1000000
               (1 x 10^6).

           ••   GG[[BB]] is power of ten ggiiggaabbyytteess where the multiplier is
               1000000000 (1 x 10^9).

           ••   TT[[BB]] is power of ten tteerraabbyytteess where the multiplier is
               1000000000000 (1 x 10^12).

           ••   PP[[BB]] is power of ten ppeettaabbyytteess where the multiplier is
               1000000000000000 (1 x 10^15).

           ••   EE[[BB]] is power of ten eexxaabbyytteess where the multiplier is
               1000000000000000000 (1 x 10^18).

     Power-of-two suffixes:

           ••   KKii[[BB]] is power of two kkiibbiibbyytteess where the multiplier is 1024 (1
               x 2^10).

           ••   MMii[[BB]] is power of two mmeebbiibbyytteess where the multiplier is 1048576
               (1 x 2^20).

           ••   GGii[[BB]] is power of two ggiibbiibbyytteess where the multiplier is
               1073741824 (1 x 2^30).

           ••   TTii[[BB]] is power of two tteebbiibbyytteess where the multiplier is
               1099511627776 (1 x 2^40).

           ••   PPii[[BB]] is power of two ppeebbiibbyytteess where the multiplier is
               1125899906842624 (1 x 2^50).

           ••   EEii[[BB]] is power of two eexxbbiibbyytteess where the multiplier is
               1152921504606846976 (1 x 2^60).

     The following are useful when working with devices and partition maps:

           ••   SS | UUAAMM ("sectors") is 551122--bbyyttee uunniittss (device-independent)
               where the multiplier is always 512.

           ••   DDBBSS ("device block size") is the ddeevviiccee--ddeeppeennddeenntt native block
               size of the encompassing whole disk, if applicable, where the
               multiplier is often 512, but not always; indeed it might not be
               a power of two.

     In certain contexts (e.g. when asking to "use all space available", or
     when building partition triplets) you can provide a relative value as
     follows:

           ••   00 (the number zero) is a request to allocate "all possible".
               This may mean different things in different contexts.  For
               partition maps, this requests allocation until the start of the
               following partition or the end of the partition map's
               allocatable space.

           ••   %% (with a preceding number) is a ppeerrcceennttaaggee of the whole-disk
               size, the partition map size, or other allocatable size, as
               appropriate by context.  Use of %% is not supported in all
               situations.

           ••   RR (with no preceding number) specifies the rreemmaaiinnddeerr of the
               whole-disk size or other allocatable size after all other
               triplets in the group are taken into account.  It need not be
               in the last triplet.  It must only appear in at most one
               triplet among all triplets.  Use of RR is not supported in all
               situations; in some such cases, a value of 00 is more
               appropriate.

     You can provide an operating system-defined constant value as follows:

           ••   %%rreeccoovveerryy%% (with no preceding number) is the customary size of
               pre-macOS-13.0 Recovery Partitions.

     Note again that BB refers to bytes and SS and UUAAMM refer to a constant
     multiplier of 512; the latter are useful when working with tools such as
     ggpptt (8) or ddff (1).  Note also that this multiplier is not a "block" size
     as actually implemented by the underlying device driver and/or hardware,
     nor is it an "allocation block", which is a file system's minimum unit of
     backing store usage, often formatting-option-dependent.

     Examples: 10G (10 gigabytes), 4.23tb (4.23 terabytes), 5M (5 megabytes),
     4GiB (exactly 2^32 bytes), 126000 (exactly 126000 bytes), 25.4% (25.4
     percent of whole disk size).

FFOORRMMAATT
     The _f_o_r_m_a_t parameter for the erasing and partitioning verbs is the file
     system personality name.  You can determine this name by looking in a
     file system bundle's
     _/_S_y_s_t_e_m_/_L_i_b_r_a_r_y_/_F_i_l_e_s_y_s_t_e_m_s_/_<_f_s_>_._f_s_/_C_o_n_t_e_n_t_s_/_I_n_f_o_._p_l_i_s_t and looking at
     the keys for the FFSSPPeerrssoonnaalliittiieess dictionary, or by using the
     lliissttFFiilleessyysstteemmss verb, which also lists shortcut aliases for common
     personalities (these shortcuts are defined by ddiisskkuuttiill for use with it
     only).

     Common examples include JHFS+, JHFSX, MS-DOS, etc, as nicknames for the
     canonical forms from the file system bundles such as "Case-sensitive
     HFS+".

AAPPFFSS VVOOLLUUMMEE RROOLLEESS
     APFS Volumes can be tagged with certain role meta-data flags. Supported
     flags are:

           ••   BB - Preboot (boot loader)

           ••   RR - Recovery

           ••   VV - VM (swap space)

           ••   II - Installer

           ••   TT - Backup (Time Machine)

           ••   SS - System

           ••   DD - Data

           ••   EE - Update

           ••   XX - XART (hardware security)

           ••   HH - Hardware

           ••   CC - Sidecar (Time Machine)

           ••   YY - Enterprise (data)

EEXXAAMMPPLLEESS
     Erase a whole disk (device):
     diskutil eraseDisk JHFS+ Untitled disk3

     Erase a volume (or format a partition or virtual disk):
     diskutil eraseVolume jhfs+ UntitledHFS /Volumes/SomeDisk

     Erase and (re)-partition a disk (device) with three partitions:
     diskutil partitionDisk disk3 HFSX Foo1 10G JHFS+ Foo2 10G MS-DOS FOO3 0

     Erase and format with a different volume file system:
     diskutil eraseVolume ExFAT FOO disk3s2

     Remove a partition from a partition map (results in free space):
     diskutil eraseVolume free free disk3s2

     Add a new partition to a partition map (into free space):
     diskutil addPartition disk3s2 ExFat FOO 0
     diskutil addPartition disk3s2 %Apple_HFS% %noformat% 2.5g
     diskutil addPartition disk3 ExFat FOO 50%

     Convert a HFS disk to APFS:
     diskutil apfs convert disk3s2

     Create a new APFS Container with three new APFS Volumes:
     diskutil apfs createContainer disk0s2
     diskutil apfs addVolume disk8 APFS MyVolume1
     diskutil apfs addVolume disk8 APFS MyVolume2 -passprompt
     diskutil apfs addVolume disk8 APFS MyVolume3 -quota 10g
     diskutil apfs list

     Encrypt an APFS Volume (enable FileVault):
     diskutil apfs encryptVolume disk8s1 -user disk

     Lock or unlock an APFS Volume:
     diskutil apfs list disk8
     diskutil apfs lockVolume disk8s1
     diskutil apfs unlockVolume disk8s1 (tries all users)
     diskutil apfs unlockVolume disk8s2 -user _U_S_E_R_U_U_I_D (tries specific user)

     Decrypt an APFS Volume (disable FileVault):
     diskutil apfs listUsers disk8s1
     diskutil apfs decryptVolume disk8s1 -user _U_S_E_R_U_U_I_D

     Remove an APFS Volume from its APFS Container altogether:
     diskutil apfs deleteVolume disk8s3

     Resize an HFS volume and create a volume after it:
     diskutil resizeVolume /Volumes/SomeDisk 50g MS-DOS DOS 0

     Resize an HFS volume and leave all remaining space as unused:
     diskutil resizeVolume /Volumes/SomeDisk 12g

     Merge two partitions into a new partition:
     diskutil mergePartitions JHFS+ not disk1s3 disk1s5

     Split a partition into three new ones:
     diskutil splitPartition /Volumes/SomeDisk JHFS+ vol1 12g MS-DOS VOL2 8g
     JHFS+ vol3 0

     Create an AppleRAID:
     diskutil createRAID mirror MirroredVolume JHFS+ disk1 disk2

     Destroy an AppleRAID:
     diskutil destroyRAID /Volumes/MirroredVolume

     Repair a damaged AppleRAID:
     diskutil repairMirror /Volumes/MirroredVolume disk3

     Convert volume into an AppleRAID volume:
     diskutil enableRAID mirror /Volumes/ExistingVolume

     Erase a partition, shrink, associate a pre-macOS-13.0 Recovery Partition:
     diskutil splitPartition disk8s2 JHFS+ MacHD R %Apple_Boot% %noformat%
     %recovery%

     Partition a disk with the MBR partitioning scheme (e.g. for a camera):
     diskutil partitionDisk disk3 MBR MS-DOS CAM1 0

     Partition a disk with the (deprecated) APM partitioning scheme:
     diskutil partitionDisk disk3 APM HFS+ vol1 15% Journaled\ HFS+ vol2 R
     Journaled\ HFS+ vol3 25% Free\ Space volX 10g

     Attach a 100MiB RAM disk image:
     diskutil image attach ram://100MiB

     Attach a read-only disk image at some specified mount point:
     diskutil image attach --readOnly --mountPoint /tmp/myMountPoint
     /tmp/myImage.dmg

     Create a blank 16GB sparse bundle disk image with an APFS volume named
     "Untitled":
     diskutil image create blank -s 16g /tmp/myImage.sparsebundle

     Create a blank 100MiB raw disk image with an APFS volume named
     "MyVolume":
     diskutil image create blank -s 100MiB --volumeName MyVolume
     /tmp/myImage.dmg

     Create a disk image with a ULFO format from an existing disk:
     diskutil image create from disk3 /tmp/myImage.dmg

     Resize a disk image:
     diskutil image resize --size 100G /tmp/my.dmg

     Resize to minimal size:
     diskutil image resize --size min /tmp/my.dmg

     Print resize limits in plist format:
     diskutil image resize --plist /tmp/my.dmg

EERRRROORRSS
     ddiisskkuuttiill will exit with status based on ssyysseexxiittss (see sysexits(3)) or 1
     if it cannot complete the requested operation; this includes cases in
     which usage text is printed.  Before ddiisskkuuttiill returns with non EEXX__OOKK
     status, it prints a message which might include an explanation local to
     diskutil, an error string from the DiskManagement or MediaKit frameworks,
     an underlying POSIX error, or some combination.

SSEEEE AALLSSOO
     authopen(1), drutil(1), hdiutil(1), apfs.util(8), corestoraged(8),
     diskarbitrationd(8), diskmanagementd(8), diskmanagementstartup(8),
     fdesetup(8), fsck_apfs(8), fsck_hfs(8), hfs.util(8), ioreg(8), mount(8),
     mount_apfs(8), msdos.util(8), newfs_apfs(8), newfs_hfs(8), sysexits(3),
     ufs.util(8), umount(8), vsdbutil(8)

HHIISSTTOORRYY
     The eraseDisk and partitionDisk verbs had an option to add Mac OS 9
     drivers (in partitions designated for that purpose); there was also a
     repairOS9Permissions verb.  These have been removed.

     Starting with Mac OS X 10.6, the input and output notation of disk and
     partition sizes use power-of-10 suffixes.  In the past this had been
     power-of-2, regardless of the suffix (e.g. G, Gi, GiB) used for display
     or accepted as input.  Starting with Mac OS X 10.11, the BB suffix is
     optional even for "bare" numeric values.

     Starting with Mac OS X 10.11, the verify- and repairPermissions verbs
     have been removed.

     Starting with macOS 10.12, the plist output of partitions from ddiisskkuuttiill
     lliisstt --pplliisstt is presented in on-disk (not BSD slice name, e.g. disk0s2)
     order. This mimics the order of outputs from programs such as ggpptt (1).
     The human-readable output always has been, and remains, in on-disk order.

     Starting with macOS 10.13.2, APFS cryptographic user authentication is
     required even when disabling FileVault.

     Starting with macOS 10.14, partitions on all media above 1GiB in size
     will default to 1MiB alignment, regardless of the partitioning scheme.
     This is significant for MBR partition maps and their use in appliances
     such as cameras. Free-space requests will not be aligned.

     Starting with macOS 11.0, certain Core Storage manipulation verbs have
     been removed.

macOS                           27 October 2021                          macOS
